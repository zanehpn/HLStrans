{
    "convolution": {
        "src": "#include \"hls_stream.h\"\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_IMAGE_WIDTH     1920\n#define MAX_IMAGE_HEIGHT    1080\n#define FILTER_V_SIZE       15\n#define FILTER_H_SIZE       15\n#ifndef MIN\n#define MIN(a,b) ((a<b)?a:b)\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a<b)?b:a)\n#endif\n\ntypedef unsigned char       U8;\ntypedef unsigned short      U16;\ntypedef unsigned int        U32;\ntypedef signed char         I8;\ntypedef signed short        I16;\ntypedef signed int          I32;\n\nvoid Filter2DKernel(\n    const char           coeffs[256],\n    float                factor,\n    short                bias,\n    unsigned short       width,\n    unsigned short       height,\n    unsigned short       stride,\n    const unsigned char  src[MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT],\n    unsigned char        dst[MAX_IMAGE_WIDTH * MAX_IMAGE_HEIGHT])\n{\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width; x++) {\n            int sum = 0;\n            for (int ky = -FILTER_V_SIZE / 2; ky <= FILTER_V_SIZE / 2; ky++) {\n                for (int kx = -FILTER_H_SIZE / 2; kx <= FILTER_H_SIZE / 2; kx++) {\n                    int src_y = y + ky;\n                    int src_x = x + kx;\n                    \n                    // Handle boundary conditions with mirroring\n                    if (src_y < 0) src_y = -src_y;\n                    if (src_x < 0) src_x = -src_x;\n                    if (src_y >= height) src_y = 2 * height - src_y - 1;\n                    if (src_x >= width) src_x = 2 * width - src_x - 1;\n                    \n                    int coef_index = (ky + FILTER_V_SIZE / 2) * FILTER_H_SIZE + (kx + FILTER_H_SIZE / 2);\n                    sum += src[src_y * width + src_x] * coeffs[coef_index];\n                }\n            }\n            int result = static_cast<int>(factor * sum) + bias;\n            dst[y * width + x] = (result < 0) ? 0 : (result > 255) ? 255 : result;\n        }\n    }\n}\n",
        "tgt": "#include \"hls_stream.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_IMAGE_WIDTH     1920\n#define MAX_IMAGE_HEIGHT    1080\n#define FILTER_V_SIZE\t\t15\n#define FILTER_H_SIZE\t\t15\n#ifndef MIN\n#define MIN(a,b) ((a<b)?a:b)\n#endif\n#ifndef MAX\n#define MAX(a,b) ((a<b)?b:a)\n#endif\n\ntypedef unsigned char      \t\tU8;\ntypedef unsigned short     \t\tU16;\ntypedef unsigned int       \t\tU32;\n\ntypedef signed char        \t\tI8;\ntypedef signed short       \t\tI16;\ntypedef signed int         \t\tI32;\n\nvoid ReadFromMem(\n        unsigned short       width,\n        unsigned short       height,\n        unsigned short       stride,\n        const char          *coeffs,\n        hls::stream<char>   &coeff_stream,\n        const unsigned char *src,\n        hls::stream<U8>     &pixel_stream )\n{\n    unsigned num_coefs = 15*15; //FILTER_V_SIZE*FILTER_H_SIZE;\n    unsigned num_coefs_padded = (((num_coefs-1)/64)+1)*64; // Make sure number of reads of multiple of 64, enables auto-widening\nL1:    read_coefs: for (int i=0; i< 288/*num_coefs_padded*/; i++) {\n        U8 coef = coeffs[i];\n        if (i<num_coefs) coeff_stream.write( coef );        \n    }\n\n    stride = (stride/64)*64; // Makes compiler see that stride is a multiple of 64, enables auto-widening\n    unsigned offset = 0;\n    unsigned x = 0;\nL2:    read_image: for (int n = 0; n < 1920*1080 /*height*stride*/; n++) {\n        U8 pix = src[n];\n        if (x<width) pixel_stream.write( pix );\n        if (x==(stride-1)) x=0; else x++;\n     }\n}\n\n\nvoid WriteToMem(\n        unsigned short       width,\n        unsigned short       height,\n        unsigned short       stride,\n        hls::stream<U8>     &pixel_stream,\n        unsigned char       *dst)\n{\n\n    stride = (stride/64)*64; // Makes compiler see that stride is a multiple of 64, enables auto-widening\n    unsigned offset = 0;\n    unsigned x = 0;\nL3:    write_image: for (int n = 0; n < 1920*1080/*height*stride*/; n++) {\n        U8 pix = (x<width) ? pixel_stream.read() : 0;\n        dst[n] = pix;\n        if (x==(stride-1)) x=0; else x++;\n    }    \n}\n\n\nstruct window {\n    U8 pix[FILTER_V_SIZE][FILTER_H_SIZE];\n};\n\n\nvoid Window2D(\n        unsigned short        width,\n        unsigned short        height,\n        hls::stream<U8>      &pixel_stream,\n        hls::stream<window>  &window_stream)\n{\n    // Line buffers - used to store [FILTER_V_SIZE-1] entire lines of pixels\nL4:    U8 LineBuffer[FILTER_V_SIZE-1][MAX_IMAGE_WIDTH];  \n#pragma HLS DEPENDENCE variable=LineBuffer inter false\n#pragma HLS DEPENDENCE variable=LineBuffer intra false\n\n    // Sliding window of [FILTER_V_SIZE][FILTER_H_SIZE] pixels\n    window Window;\n\n    unsigned col_ptr = 0;\n    unsigned ramp_up = 1920*((FILTER_V_SIZE-1)/2)+(FILTER_H_SIZE-1)/2; //width*((FILTER_V_SIZE-1)/2)+(FILTER_H_SIZE-1)/2;\n    unsigned num_pixels = 1920*1080;//width*height;\n    unsigned num_iterations = num_pixels + ramp_up;\n\n    const unsigned max_iterations = MAX_IMAGE_WIDTH*MAX_IMAGE_HEIGHT + MAX_IMAGE_WIDTH*((FILTER_V_SIZE-1)/2)+(FILTER_H_SIZE-1)/2;\n\n    // Iterate until all pixels have been processed\nL5:    update_window: for (int n=0; n< 2087054/*num_iterations*/; n++)\n    {\n#pragma HLS LOOP_TRIPCOUNT max=max_iterations\n\n        // Read a new pixel from the input stream\n        U8 new_pixel = (n<num_pixels) ? pixel_stream.read() : 0;\n\n        // Shift the window and add a column of new pixels from the line buffer\nL6:        for(int i = 0; i < FILTER_V_SIZE; i++) {\nL7:            for(int j = 0; j < FILTER_H_SIZE-1; j++) {\n                Window.pix[i][j] = Window.pix[i][j+1];\n            }\n            Window.pix[i][FILTER_H_SIZE-1] = (i<FILTER_V_SIZE-1) ? LineBuffer[i][col_ptr] : new_pixel;\n        }\n\n        // Shift pixels in the column of pixels in the line buffer, add the newest pixel\nL8:        for(int i = 0; i < FILTER_V_SIZE-2; i++) {\n            LineBuffer[i][col_ptr] = LineBuffer[i+1][col_ptr];\n        }\n        LineBuffer[FILTER_V_SIZE-2][col_ptr] = new_pixel;\n\n        // Update the line buffer column pointer\n        if (col_ptr==(width-1)) {\n            col_ptr = 0;\n        } else {\n            col_ptr++;\n        }\n\n        // Write output only when enough pixels have been read the buffers and ramped-up\n        if (n>=ramp_up) {\n            window_stream.write(Window);\n        }\n\n    }\n}\n\nvoid Filter2D(\n        unsigned short       width,\n        unsigned short       height,\n        float                factor,\n        short                bias,\n        hls::stream<char>   &coeff_stream,\n        hls::stream<window> &window_stream,\n\t\thls::stream<U8>     &pixel_stream )\n{\n\n    // Filtering coefficients\nL9:    char coeffs[FILTER_V_SIZE][FILTER_H_SIZE];\n\n    // Load the coefficients into local storage\nL10:    load_coefs: for (int i=0; i<FILTER_V_SIZE; i++) {\nL11:        for (int j=0; j<FILTER_H_SIZE; j++) {\n            coeffs[i][j] = coeff_stream.read();\n        }\n    }\n\n    // Process the incoming stream of pixel windows\nL12:    apply_filter: for (int y = 0; y < 1080/*height*/; y++) \n    {\nL13:        for (int x = 0; x < 1920/*width*/; x++) \n        {\n            // Read a 2D window of pixels\n            window w = window_stream.read();\n\n            // Apply filter to the 2D window\n            int sum = 0;\nL14:            for(int row=0; row<FILTER_V_SIZE; row++) \n            {\nL15:                for(int col=0; col<FILTER_H_SIZE; col++) \n                {\n                    unsigned char pixel;\n                    int xoffset = (x+col-(FILTER_H_SIZE/2));\n                    int yoffset = (y+row-(FILTER_V_SIZE/2));\n                    // Deal with boundary conditions : clamp pixels to 0 when outside of image \n                    if ( (xoffset<0) || (xoffset>=width) || (yoffset<0) || (yoffset>=height) ) {\n                        pixel = 0;\n                    } else {\n                        pixel = w.pix[row][col];\n                    }\n                    sum += pixel*(char)coeffs[row][col];\n                }\n            }\n\n            // Normalize result\n            unsigned char outpix = MIN(MAX((int(factor * sum)+bias), 0), 255);\n\n            // Write the output pixel\n            pixel_stream.write(outpix);\n        }\n    }\n}\n\n\nvoid convolution(\n        const char           coeffs[256],\n        float                factor,\n        short                bias,\n        unsigned short       width,\n        unsigned short       height,\n        unsigned short       stride,\n        const unsigned char  src[MAX_IMAGE_WIDTH*MAX_IMAGE_HEIGHT],\n        unsigned char        dst[MAX_IMAGE_WIDTH*MAX_IMAGE_HEIGHT])\n  {\n            \n#pragma HLS DATAFLOW\n\n\t// Stream of pixels from kernel input to filter, and from filter to output\n    hls::stream<char,2>    coefs_stream;\n    hls::stream<U8,2>      pixel_stream;\n    hls::stream<window,3>  window_stream; // Set FIFO depth to 0 to minimize resources\n    hls::stream<U8,64>     output_stream;\n\n\t// Read image data from global memory over AXI4 MM, and stream pixels out\n    ReadFromMem(width, height, stride, coeffs, coefs_stream, src, pixel_stream);\n\n    // Read incoming pixels and form valid HxV windows\n    Window2D(width, height, pixel_stream, window_stream);\n\n\t// Process incoming stream of pixels, and stream pixels out\n\tFilter2D(width, height, factor, bias, coefs_stream, window_stream, output_stream);\n\n\t// Write incoming stream of pixels and write them to global memory over AXI4 MM\n\tWriteToMem(width, height, stride, output_stream, dst);\n\n  }\n"
    },
    "tsp": {
        "src": "#include <algorithm>\n#include <limits>\n#include <hls_stream.h>\n#include <stdint.h>\n\nconst int N = 5;\n\nconstexpr long int factorial(const int N) {\n    long int ret = 1;\n    for (int i = 0; i < N; ++i)\n        ret = ret * (i + 1);\n    return ret;\n}\n\nunsigned int getDistance(const int perm[N], const uint16_t distances[N][N]) {\n    unsigned int ret = 0;\n    for (int i = 0; i < N - 1; ++i)\n        ret += distances[perm[i]][perm[i + 1]];\n    return ret;\n}\n\nint compute(unsigned long int i_, const uint16_t distances[N][N]) {\n#pragma HLS INLINE\n    unsigned long int i = i_;\n    int perm[N] = {0};\n\n    // Generate permutation in factorial number system\n    for (int k = 0; k < N; ++k) {\n        perm[k] = i / factorial(N - 1 - k);\n        i = i % factorial(N - 1 - k);\n    }\n    // Adjust the permutation values\n    for (char k = N - 1; k > 0; --k)\n        for (char j = k - 1; j >= 0; --j)\n            perm[k] += (perm[j] <= perm[k]);\n    \n    return getDistance(perm, distances);\n}\n\nvoid tsp(hls::stream<uint16_t>& streamDistances, unsigned int& shortestDistance) {\n    // AXI-Stream interface for distances\n#pragma HLS INTERFACE axis port=streamDistances\n#pragma HLS INTERFACE ap_ctrl_none port=return\n\n    // Read the distance matrix from the stream\n    uint16_t distances[N][N];\n    for (int i = 0; i < N * N; ++i) {\n        uint16_t val;\n        streamDistances >> val;\n        distances[i / N][i % N] = val;\n    }\n\n    // Iterate over all (N-1)! permutations (one city fixed)\n    constexpr long int fact = factorial(N - 1);\n    unsigned int candidate = std::numeric_limits<unsigned int>::max();\n    for (unsigned long int i = 0; i < fact; ++i) {\n#pragma HLS PIPELINE II=1\n        candidate = std::min(candidate, (unsigned int)compute(i, distances));\n    }\n\n    shortestDistance = candidate;\n}\n\n",
        "tgt": "\n\n#include <algorithm>\n#include <iostream>\n#include <array>\n#include <cmath>\n#include <numeric>\n#include <iomanip>\n#include <limits>\n#include <hls_stream.h>\n\nconst int N = 5;\nstruct Coord\n{\n  float x;\n  float y;\n};\nconstexpr long int factorial(const int N)\n{\n    long int ret = 1;\n/*L1:*/    for(int i = 0 ; i < N; ++i)\n      ret = ret * (i+1);\n    return ret;\n}\ntemplate<typename T>\nunsigned int getDistance(const T perm[N], const uint16_t distances[N][N])\n{\n  unsigned int ret = 0;\n/*L2:*/  for(int i = 0; i < N-1; ++i)\n    ret += distances[perm[i]][perm[i+1]];\n  return ret;\n\n}\nauto compute(const unsigned long int i_, const uint16_t distances[N][N])\n{\n  #pragma HLS INLINE\n\n  unsigned long int i = i_;\n/*L3:*/  int perm[N] = {0};\n\n/*L4:*/  for (int k = 0; k < N; ++k) {\n    perm[k] = i / factorial(N - 1 - k);\n    i = i % factorial(N - 1 - k);\n  }\n/*L5:*/  for (char k = N - 1; k > 0; --k)\n/*L6:*/    for (char j = k - 1; j >= 0; --j)\n      perm[k] += (perm[j] <= perm[k]);\n  return getDistance(perm,distances);\n\n}\nvoid tsp(hls::stream<uint16_t>& streamDistances, unsigned int& shortestDistance)\n{\n    // defines our input as coming from an AXI-Stream via the INTERFACE pragma\n    #pragma HLS INTERFACE axis port=streamDistances\n\n/*L7:*/    uint16_t distances_0[N][N];\n/*L8:*/    uint16_t distances_1[N][N];\n/*L9:*/    uint16_t distances_2[N][N];\n/*L10:*/    uint16_t distances_3[N][N];\n    #pragma HLS BIND_STORAGE variable=distances_0 type=ram_1wnr\n    #pragma HLS BIND_STORAGE variable=distances_1 type=ram_1wnr\n    #pragma HLS BIND_STORAGE variable=distances_2 type=ram_1wnr\n    #pragma HLS BIND_STORAGE variable=distances_3 type=ram_1wnr\n\n    // Load the 'distances_0..7' arrays\n/*L11:*/    loop_distances: for (int i = 0; i < N*N; ++i)\n    {\n        uint16_t val;\n        streamDistances >> val;\n        distances_0[i/N][i%N] = val;\n        distances_1[i/N][i%N] = val;\n        distances_2[i/N][i%N] = val;\n        distances_3[i/N][i%N] = val;\n    }\n\n    // Main loop with (N-1)! iterations as one city is fixed\n    constexpr long int factorialN = factorial(N-1);\n    unsigned int candidate0 = std::numeric_limits<unsigned int>::max();\n    unsigned int candidate1 = std::numeric_limits<unsigned int>::max();\n    unsigned int candidate2 = std::numeric_limits<unsigned int>::max();\n    unsigned int candidate3 = std::numeric_limits<unsigned int>::max();\n/*L12:*/    loop_compute: for( unsigned long int i_ = 0; i_ < factorialN; i_ += 4 )\n    {\n      candidate0 = std::min(candidate0, compute(i_+0, distances_0));\n      candidate1 = std::min(candidate1, compute(i_+1, distances_1));\n      candidate2 = std::min(candidate2, compute(i_+2, distances_2));\n      candidate3 = std::min(candidate3, compute(i_+3, distances_3));\n    }\n\n    // Determine shortest between the 4 candidates\n    shortestDistance = std::min({ candidate0, candidate1,\n                                  candidate2, candidate3 });\n\n\n}"
    },
    "rendering": {
        "src": "const int MAX_X = 32;\nconst int MAX_Y = 32;\n\nconst int NUM_FB = MAX_X * MAX_Y / 4;\n// dataset information \nconst int NUM_3D_TRI = 3192;\ntypedef unsigned char bit8;\ntypedef unsigned int bit32;\n// struct: 3D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   z0;\n  bit8   x1;\n  bit8   y1;\n  bit8   z1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z2;\n} Triangle_3D;\n\n// struct: 2D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   x1;\n  bit8   y1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z;\n} Triangle_2D;\n\n// struct: candidate pixels\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   z;\n  bit8   color;\n} CandidatePixel;\n\n// struct: colored pixel\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   color;\n} Pixel;\n\nint check_clockwise( Triangle_2D triangle_2d )\n{\n  int cw;\n\n  cw = (triangle_2d.x2 - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0)\n       - (triangle_2d.y2 - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n\n  return cw;\n\n}\n\n// swap (x0, y0) (x1, y1) of a Triangle_2D\nvoid clockwise_vertices( Triangle_2D *triangle_2d )\n{\n\n  bit8 tmp_x, tmp_y;\n\n  tmp_x = triangle_2d->x0;\n  tmp_y = triangle_2d->y0;\n\n  triangle_2d->x0 = triangle_2d->x1;\n  triangle_2d->y0 = triangle_2d->y1;\n\n  triangle_2d->x1 = tmp_x;\n  triangle_2d->y1 = tmp_y;\n\n}\n\n\n// Given a pixel, determine whether it is inside the triangle\n// by Pineda algorithm\n// if so, return true\n// else, return false\nchar pixel_in_triangle( bit8 x, bit8 y, Triangle_2D triangle_2d )\n{\n\n  int pi0, pi1, pi2;\n\n  pi0 = (x - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0) - (y - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n  pi1 = (x - triangle_2d.x1) * (triangle_2d.y2 - triangle_2d.y1) - (y - triangle_2d.y1) * (triangle_2d.x2 - triangle_2d.x1);\n  pi2 = (x - triangle_2d.x2) * (triangle_2d.y0 - triangle_2d.y2) - (y - triangle_2d.y2) * (triangle_2d.x0 - triangle_2d.x2);\n\n  return (pi0 >= 0 && pi1 >= 0 && pi2 >= 0);\n}\n\n// find the min from 3 integers\nbit8 find_min( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 < in1)\n  {\n    if (in0 < in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 < in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n\n// find the max from 3 integers\nbit8 find_max( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 > in1)\n  {\n    if (in0 > in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 > in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n/*======================PROCESSING STAGES========================*/\n\n// project a 3D triangle to a 2D triangle\nvoid projection ( Triangle_3D triangle_3d, Triangle_2D *triangle_2d, int angle )\n{\n  // Setting camera to (0,0,-1), the canvas at z=0 plane\n  // The 3D model lies in z>0 space\n  // The coordinate on canvas is proportional to the corresponding coordinate \n  // on space\n  if(angle == 0)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.z0 / 3 + triangle_3d.z1 / 3 + triangle_3d.z2 / 3;\n  }\n\n  else if(angle == 1)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.z0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.z1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.z2;\n    triangle_2d->z  = triangle_3d.y0 / 3 + triangle_3d.y1 / 3 + triangle_3d.y2 / 3;\n  }\n      \n  else if(angle == 2)\n  {\n    triangle_2d->x0 = triangle_3d.z0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.z1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.z2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.x0 / 3 + triangle_3d.x1 / 3 + triangle_3d.x2 / 3;\n  }\n}\n\n// calculate bounding box for a 2D triangle\nchar rasterization1 ( Triangle_2D triangle_2d, bit8 max_min[], int max_index[])\n{\n  // clockwise the vertices of input 2d triangle\n  if ( check_clockwise( triangle_2d ) == 0 )\n    return 1;\n  if ( check_clockwise( triangle_2d ) < 0 )\n    clockwise_vertices( &triangle_2d );\n\n  // find the rectangle bounds of 2D triangles\n  max_min[0] = find_min( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[1] = find_max( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[2] = find_min( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[3] = find_max( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[4] = max_min[1] - max_min[0];\n\n  // calculate index for searching pixels\n  max_index[0] = (max_min[1] - max_min[0]) * (max_min[3] - max_min[2]);\n\n  return 0;\n}\n\n// find pixels in the triangles from the bounding box\nint rasterization2 ( char flag, bit8 max_min[], int max_index[], Triangle_2D triangle_2d, CandidatePixel fragment[] )\n{\n  // clockwise the vertices of input 2d triangle\n  if ( flag )\n  {\n    return 0;\n  }\n\n  bit8 color = 100;\n  int i = 0;\n\n  RAST2: for ( int k = 0; k < max_index[0]; k ++ )\n  {\n    bit8 x = max_min[0] + k % max_min[4];\n    bit8 y = max_min[2] + k / max_min[4];\n\n    if( pixel_in_triangle( x, y, triangle_2d ) )\n    {\n      fragment[i].x = x;\n      fragment[i].y = y;\n      fragment[i].z = triangle_2d.z;\n      fragment[i].color = color;\n      i++;\n    }\n  }\n\n  return i;\n}\n\n// filter hidden pixels\nint zculling ( int counter, CandidatePixel fragments[], int size, Pixel pixels[])\n{\n\n  // initilize the z-buffer in rendering first triangle for an image\n  static bit8 z_buffer[MAX_X][MAX_Y];\n  if (counter == 0)\n  {\n    ZCULLING_INIT_ROW: for ( int i = 0; i < MAX_X; i ++ )\n    {\n      ZCULLING_INIT_COL: for ( int j = 0; j < MAX_Y; j ++ )\n      {\n        z_buffer[i][j] = 255;\n      }\n    }\n  }\n\n  // pixel counter\n  int pixel_cntr = 0;\n  \n  // update z-buffer and pixels\n  ZCULLING: for ( int n = 0; n < size; n ++ ) \n  {\n    if( fragments[n].z < z_buffer[fragments[n].y][fragments[n].x] )\n    {\n      pixels[pixel_cntr].x     = fragments[n].x;\n      pixels[pixel_cntr].y     = fragments[n].y;\n      pixels[pixel_cntr].color = fragments[n].color;\n      pixel_cntr++;\n      z_buffer[fragments[n].y][fragments[n].x] = fragments[n].z;\n    }\n  }\n\n  return pixel_cntr;\n}\n\n// color the frame buffer\nvoid coloringFB(int counter, int size_pixels, Pixel pixels[], bit8 frame_buffer[MAX_X][MAX_Y])\n{\n\n  if ( counter == 0 )\n  {\n    // initilize the framebuffer for a new image\n    COLORING_FB_INIT_ROW: for ( int i = 0; i < MAX_X; i ++ )\n    {\n      COLORING_FB_INIT_COL: for ( int j = 0; j < MAX_Y; j ++ )\n        frame_buffer[i][j] = 0;\n    }\n  }\n\n  // update the framebuffer\n  COLORING_FB: for ( int i = 0; i < size_pixels; i ++ )\n    frame_buffer[ pixels[i].x ][ pixels[i].y ] = pixels[i].color;\n\n}\n\nvoid rendering( Triangle_3D triangle_3ds[NUM_3D_TRI], bit8 output[MAX_X][MAX_Y])\n{\n#pragma HLS INTERFACE m_axi port=triangle_3ds offset=slave bundle=gmem0\n#pragma HLS INTERFACE m_axi port=output offset=slave bundle=gmem1\n\n#pragma HLS INTERFACE s_axilite port=return bundle=control\n\n  // local variables\n\n  // 2D triangle\n  Triangle_2D triangle_2ds;\n  // projection angle\n  int angle = 0;\n\n  // max-min index arrays\n  bit8 max_min[5];\n  int max_index[1];\n\n  // fragments\n  CandidatePixel fragment[500];\n\n  // pixel buffer\n  Pixel pixels[500];\n\n  // processing NUM_3D_TRI 3D triangles\n  TRIANGLES: for (int i = 0; i < NUM_3D_TRI; i ++ )\n  {\n    // five stages for processing each 3D triangle\n    projection( triangle_3ds[i], &triangle_2ds, angle );\n    char flag = rasterization1(triangle_2ds, max_min, max_index);\n    int size_fragment = rasterization2( flag, max_min, max_index, triangle_2ds, fragment );\n    int size_pixels = zculling( i, fragment, size_fragment, pixels);\n    coloringFB ( i, size_pixels, pixels, output);\n  }\n\n}\n\n",
        "tgt": "\n// resolution 256x256\nconst int MAX_X = 256;\nconst int MAX_Y = 256;\n\n// number of values in frame buffer: 32 bits\nconst int NUM_FB = MAX_X * MAX_Y / 4;\n// dataset information \nconst int NUM_3D_TRI = 3192;\n\n\n#include \"ap_int.h\"\n// specialized datatypes\ntypedef ap_uint<1> bit1;\ntypedef ap_uint<2> bit2;\ntypedef ap_uint<8> bit8;\ntypedef ap_uint<16> bit16;\ntypedef ap_uint<32> bit32;\n\n\n// struct: 3D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   z0;\n  bit8   x1;\n  bit8   y1;\n  bit8   z1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z2;\n} Triangle_3D;\n\n// struct: 2D triangle\ntypedef struct\n{\n  bit8   x0;\n  bit8   y0;\n  bit8   x1;\n  bit8   y1;\n  bit8   x2;\n  bit8   y2;\n  bit8   z;\n} Triangle_2D;\n\n// struct: candidate pixels\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   z;\n  bit8   color;\n} CandidatePixel;\n\n// struct: colored pixel\ntypedef struct\n{\n  bit8   x;\n  bit8   y;\n  bit8   color;\n} Pixel;\n\nint check_clockwise( Triangle_2D triangle_2d )\n{\n  int cw;\n\n  cw = (triangle_2d.x2 - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0)\n       - (triangle_2d.y2 - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n\n  return cw;\n\n}\n\n// swap (x0, y0) (x1, y1) of a Triangle_2D\nvoid clockwise_vertices( Triangle_2D *triangle_2d )\n{\n\n  bit8 tmp_x, tmp_y;\n\n  tmp_x = triangle_2d->x0;\n  tmp_y = triangle_2d->y0;\n\n  triangle_2d->x0 = triangle_2d->x1;\n  triangle_2d->y0 = triangle_2d->y1;\n\n  triangle_2d->x1 = tmp_x;\n  triangle_2d->y1 = tmp_y;\n\n}\n\nbit1 pixel_in_triangle( bit8 x, bit8 y, Triangle_2D triangle_2d )\n{\n\n  int pi0, pi1, pi2;\n\n  pi0 = (x - triangle_2d.x0) * (triangle_2d.y1 - triangle_2d.y0) - (y - triangle_2d.y0) * (triangle_2d.x1 - triangle_2d.x0);\n  pi1 = (x - triangle_2d.x1) * (triangle_2d.y2 - triangle_2d.y1) - (y - triangle_2d.y1) * (triangle_2d.x2 - triangle_2d.x1);\n  pi2 = (x - triangle_2d.x2) * (triangle_2d.y0 - triangle_2d.y2) - (y - triangle_2d.y2) * (triangle_2d.x0 - triangle_2d.x2);\n\n  return (pi0 >= 0 && pi1 >= 0 && pi2 >= 0);\n}\n\n// find the min from 3 integers\nbit8 find_min( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 < in1)\n  {\n    if (in0 < in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 < in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n\n// find the max from 3 integers\nbit8 find_max( bit8 in0, bit8 in1, bit8 in2 )\n{\n  if (in0 > in1)\n  {\n    if (in0 > in2)\n      return in0;\n    else \n      return in2;\n  }\n  else \n  {\n    if (in1 > in2) \n      return in1;\n    else \n      return in2;\n  }\n}\n\n/*======================PROCESSING STAGES========================*/\n\n// project a 3D triangle to a 2D triangle\nvoid projection ( Triangle_3D triangle_3d, Triangle_2D *triangle_2d, bit2 angle )\n{\n  #pragma HLS INLINE off\n  // Setting camera to (0,0,-1), the canvas at z=0 plane\n  // The 3D model lies in z>0 space\n  // The coordinate on canvas is proportional to the corresponding coordinate \n  // on space\n  if(angle == 0)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.z0 / 3 + triangle_3d.z1 / 3 + triangle_3d.z2 / 3;\n  }\n\n  else if(angle == 1)\n  {\n    triangle_2d->x0 = triangle_3d.x0;\n    triangle_2d->y0 = triangle_3d.z0;\n    triangle_2d->x1 = triangle_3d.x1;\n    triangle_2d->y1 = triangle_3d.z1;\n    triangle_2d->x2 = triangle_3d.x2;\n    triangle_2d->y2 = triangle_3d.z2;\n    triangle_2d->z  = triangle_3d.y0 / 3 + triangle_3d.y1 / 3 + triangle_3d.y2 / 3;\n  }\n      \n  else if(angle == 2)\n  {\n    triangle_2d->x0 = triangle_3d.z0;\n    triangle_2d->y0 = triangle_3d.y0;\n    triangle_2d->x1 = triangle_3d.z1;\n    triangle_2d->y1 = triangle_3d.y1;\n    triangle_2d->x2 = triangle_3d.z2;\n    triangle_2d->y2 = triangle_3d.y2;\n    triangle_2d->z  = triangle_3d.x0 / 3 + triangle_3d.x1 / 3 + triangle_3d.x2 / 3;\n  }\n}\n\n// calculate bounding box for a 2D triangle\nbit2 rasterization1 ( Triangle_2D triangle_2d, bit8 max_min[], Triangle_2D *triangle_2d_same, bit16 max_index[])\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( check_clockwise( triangle_2d ) == 0 )\n    return 1;\n  if ( check_clockwise( triangle_2d ) < 0 )\n    clockwise_vertices( &triangle_2d );\n\n  // copy the same 2D triangle\n  triangle_2d_same->x0 = triangle_2d.x0;\n  triangle_2d_same->y0 = triangle_2d.y0;\n  triangle_2d_same->x1 = triangle_2d.x1;\n  triangle_2d_same->y1 = triangle_2d.y1;\n  triangle_2d_same->x2 = triangle_2d.x2;\n  triangle_2d_same->y2 = triangle_2d.y2;\n  triangle_2d_same->z  = triangle_2d.z ;\n\n  // find the rectangle bounds of 2D triangles\n  max_min[0] = find_min( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[1] = find_max( triangle_2d.x0, triangle_2d.x1, triangle_2d.x2 );\n  max_min[2] = find_min( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[3] = find_max( triangle_2d.y0, triangle_2d.y1, triangle_2d.y2 );\n  max_min[4] = max_min[1] - max_min[0];\n\n  // calculate index for searching pixels\n  max_index[0] = (max_min[1] - max_min[0]) * (max_min[3] - max_min[2]);\n\n  return 0;\n}\n\n// find pixels in the triangles from the bounding box\nbit16 rasterization2 ( bit2 flag, bit8 max_min[], bit16 max_index[], Triangle_2D triangle_2d_same, CandidatePixel fragment2[] )\n{\n  #pragma HLS INLINE off\n  // clockwise the vertices of input 2d triangle\n  if ( flag )\n  {\n    return 0;\n  }\n  bit8 color = 100;\n  bit16 i = 0;\n\n  RAST2: for ( bit16 k = 0; k < max_index[0]; k++ )\n  {\n    #pragma HLS PIPELINE II=1\n    bit8 x = max_min[0] + k%max_min[4];\n    bit8 y = max_min[2] + k/max_min[4];\n\n    if( pixel_in_triangle( x, y, triangle_2d_same ) )\n    {\n      fragment2[i].x = x;\n      fragment2[i].y = y;\n      fragment2[i].z = triangle_2d_same.z;\n      fragment2[i].color = color;\n      i++;\n    }\n  }\n\n  return i;\n}\n\n// filter hidden pixels\nbit16 zculling ( bit16 counter, CandidatePixel fragments[], bit16 size, Pixel pixels[])\n{\n  #pragma HLS INLINE off\n\n  // initilize the z-buffer in rendering first triangle for an image\n  static bit8 z_buffer[MAX_X][MAX_Y];\n  if (counter == 0)\n  {\n    ZCULLING_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      ZCULLING_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n      {\n        z_buffer[i][j] = 255;\n      }\n    }\n  }\n\n  // pixel counter\n  bit16 pixel_cntr = 0;\n  \n  // update z-buffer and pixels\n  ZCULLING: for ( bit16 n = 0; n < size; n++ ) \n  {\n    #pragma HLS PIPELINE II=1\n    if( fragments[n].z < z_buffer[fragments[n].y][fragments[n].x] )\n    {\n      pixels[pixel_cntr].x     = fragments[n].x;\n      pixels[pixel_cntr].y     = fragments[n].y;\n      pixels[pixel_cntr].color = fragments[n].color;\n      pixel_cntr++;\n      z_buffer[fragments[n].y][fragments[n].x] = fragments[n].z;\n    }\n  }\n\n  return pixel_cntr;\n}\n\n// color the frame buffer\nvoid coloringFB(bit16 counter,  bit16 size_pixels, Pixel pixels[], bit8 frame_buffer[MAX_X][MAX_Y])\n{\n  #pragma HLS INLINE off\n\n  if ( counter == 0 )\n  {\n    // initilize the framebuffer for a new image\n    COLORING_FB_INIT_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n    {\n      #pragma HLS PIPELINE II=1\n      COLORING_FB_INIT_COL: for ( bit16 j = 0; j < MAX_Y; j++)\n        frame_buffer[i][j] = 0;\n    }\n  }\n\n  // update the framebuffer\n  COLORING_FB: for ( bit16 i = 0; i < size_pixels; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    frame_buffer[ pixels[i].x ][ pixels[i].y ] = pixels[i].color;\n  }\n\n}\n\n// stream out the frame buffer\nvoid output_FB(bit8 frame_buffer[MAX_X][MAX_Y], bit32 output[NUM_FB])\n{\n  #pragma HLS INLINE\n  bit32 out_FB = 0;\n  OUTPUT_FB_ROW: for ( bit16 i = 0; i < MAX_X; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    OUTPUT_FB_COL: for ( bit16 j = 0; j < MAX_Y; j = j + 4)\n    {\n      out_FB( 7,  0) = frame_buffer[i][j + 0];\n      out_FB(15,  8) = frame_buffer[i][j + 1];\n      out_FB(23, 16) = frame_buffer[i][j + 2];\n      out_FB(31, 24) = frame_buffer[i][j + 3];\n      output[i * MAX_Y / 4 + j / 4] = out_FB;\n    }\n  }\n}\n\n\n/*========================TOP FUNCTION===========================*/\nvoid rendering( bit32 input[3*NUM_3D_TRI], bit32 output[NUM_FB])\n{\n  // local variables\n  Triangle_3D triangle_3ds;\n  Triangle_2D triangle_2ds;\n  Triangle_2D triangle_2ds_same;\n\n  bit16 size_fragment;\n  CandidatePixel fragment[500];\n\n  bit16 size_pixels;\n  Pixel pixels[500];\n\n  bit8 frame_buffer[MAX_X][MAX_Y];\n  bit2 angle = 0;\n\n  bit8 max_min[5];\n  bit16 max_index[1];\n  bit2 flag;\n\n  // processing NUM_3D_TRI 3D triangles\n  TRIANGLES: for (bit16 i = 0; i < NUM_3D_TRI; i++)\n  {\n    bit32 input_lo  = input[3*i];\n    bit32 input_mi  = input[3*i+1];\n    bit32 input_hi  = input[3*i+2];\n\n    triangle_3ds.x0 = input_lo( 7,  0);\n    triangle_3ds.y0 = input_lo(15,  8);\n    triangle_3ds.z0 = input_lo(23, 16);\n    triangle_3ds.x1 = input_lo(31, 24);\n    triangle_3ds.y1 = input_mi( 7,  0);\n    triangle_3ds.z1 = input_mi(15,  8);\n    triangle_3ds.x2 = input_mi(23, 16);\n    triangle_3ds.y2 = input_mi(31, 24);\n    triangle_3ds.z2 = input_hi( 7,  0);\n\n    #ifdef USE_DATAFLOW\n      #pragma HLS dataflow\n    #endif\n\n    // five stages for processing each 3D triangle\n    projection( triangle_3ds, &triangle_2ds, angle );\n    flag = rasterization1( triangle_2ds, max_min, &triangle_2ds_same, max_index);\n    size_fragment = rasterization2( flag, max_min, max_index, triangle_2ds_same, fragment );\n    size_pixels = zculling( i, fragment, size_fragment, pixels);\n    coloringFB ( i, size_pixels, pixels, frame_buffer);\n  }\n\n  // output values: frame buffer\n  output_FB(frame_buffer,output);\n}\n\n"
    },
    "optical_flow": {
        "src": "const int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\n\n\ntypedef float pixel_t;\ntypedef float outer_pixel_t;\ntypedef float vel_pixel_t;\n\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\n\n// compute x, y gradient\nvoid gradient_xy_calc(pixel_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  pixel_t x_grad, y_grad;\n  for (int r = 0; r < MAX_HEIGHT + 2; r ++ )\n  {\n    for (int c = 0; c < MAX_WIDTH + 2; c ++)\n    {\n      x_grad = 0;\n      y_grad = 0;\n      if (r >= 4 && r < MAX_HEIGHT && c >= 4 && c < MAX_WIDTH)\n      {\n        for (int i = 0; i < 5; i++)\n        {\n          x_grad += frame[r-2][c-i] * GRAD_WEIGHTS[4-i];\n          y_grad += frame[r-i][c-2] * GRAD_WEIGHTS[4-i];\n        }\n        gradient_x[r-2][c-2] = x_grad / 12;\n        gradient_y[r-2][c-2] = y_grad / 12;\n      }\n      else if (r >= 2 && c >= 2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// compute z gradient\nvoid gradient_z_calc(pixel_t frame0[MAX_HEIGHT][MAX_WIDTH], \n                     pixel_t frame1[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame2[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame3[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame4[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  for (int r = 0; r < MAX_HEIGHT; r ++)\n  {\n    for (int c = 0; c < MAX_WIDTH; c ++)\n    {\n      gradient_z[r][c] = 0.0f;\n      gradient_z[r][c] += frame0[r][c] * GRAD_WEIGHTS[0]; \n      gradient_z[r][c] += frame1[r][c] * GRAD_WEIGHTS[1]; \n      gradient_z[r][c] += frame2[r][c] * GRAD_WEIGHTS[2]; \n      gradient_z[r][c] += frame3[r][c] * GRAD_WEIGHTS[3]; \n      gradient_z[r][c] += frame4[r][c] * GRAD_WEIGHTS[4]; \n      gradient_z[r][c] /= 12.0f;\n    }\n  }\n}\n\n// compute y weight\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n                       pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n                       pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  for (int r = 0; r < MAX_HEIGHT + 3; r ++)\n  {\n    for (int c = 0; c < MAX_WIDTH; c ++)\n    {\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if (r >= 6 && r < MAX_HEIGHT)\n      { \n        for (int i = 0; i < 7; i ++)\n        {\n          acc.x += gradient_x[r-i][c] * GRAD_FILTER[i];\n          acc.y += gradient_y[r-i][c] * GRAD_FILTER[i];\n          acc.z += gradient_z[r-i][c] * GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;            \n      }\n      else if (r >= 3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// compute x weight\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  for (int r = 0; r < MAX_HEIGHT; r ++)\n  {\n    for (int c = 0; c < MAX_WIDTH + 3; c ++)\n    {\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if (c >= 6 && c < MAX_WIDTH)\n      {\n        for (int i = 0; i < 7; i ++)\n        {\n          acc.x += y_filt[r][c-i].x * GRAD_FILTER[i];\n          acc.y += y_filt[r][c-i].y * GRAD_FILTER[i];\n          acc.z += y_filt[r][c-i].z * GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if (c >= 3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n \n// outer product\nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n                   outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{ \n  for (int r = 0; r < MAX_HEIGHT; r ++)\n  {\n    for (int c = 0; c < MAX_WIDTH; c ++)\n    {\n      gradient_t grad = gradient[r][c];\n      outer_t out;\n      out.val[0] = grad.x * grad.x;\n      out.val[1] = grad.y * grad.y;\n      out.val[2] = grad.z * grad.z;\n      out.val[3] = grad.x * grad.y;\n      out.val[4] = grad.x * grad.z;\n      out.val[5] = grad.y * grad.z;\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight y\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  for (int r = 0; r < MAX_HEIGHT + 1; r ++)\n  {\n    for(int c = 0; c < MAX_WIDTH; c ++)\n    {\n      tensor_t acc;\n      for (int k = 0; k < 6; k ++)\n      {\n        acc.val[k] = 0;\n      }\n\n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        for (int i = 0; i < 3; i ++)\n        {\n          for(int component = 0; component < 6; component ++)\n          {\n            acc.val[component] += outer[r-i][c].val[component] * TENSOR_FILTER[i];\n          }\n        }\n      }\n      if (r >= 1)\n      { \n        tensor_y[r-1][c] = acc;            \n      }\n    }\n  }\n}\n\n// tensor weight x\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  for (int r = 0; r < MAX_HEIGHT; r ++)\n  {\n    for (int c = 0; c < MAX_WIDTH + 1; c ++)\n    {\n      tensor_t acc;\n      for(int k = 0; k < 6; k++)\n      {\n        acc.val[k] = 0;\n      }\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        for (int i = 0; i < 3; i ++)\n        {\n          for (int component = 0; component < 6; component ++)\n          {\n            acc.val[component] += tensor_y[r][c-i].val[component] * TENSOR_FILTER[i];\n          }\n        }\n      }\n      if (c >= 1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t output[MAX_HEIGHT][MAX_WIDTH])\n{\n  for(int r = 0; r < MAX_HEIGHT; r ++)\n  {\n    for(int c = 0; c < MAX_WIDTH; c ++)\n    {\n      if (r >= 2 && r < MAX_HEIGHT - 2 && c >= 2 && c < MAX_WIDTH - 2)\n      {\n        pixel_t denom = tensors[r][c].val[0] * tensors[r][c].val[1] -\n                        tensors[r][c].val[3] * tensors[r][c].val[3];\n        output[r][c].x = (tensors[r][c].val[5] * tensors[r][c].val[3] -\n                          tensors[r][c].val[4] * tensors[r][c].val[1]) / denom;\n        output[r][c].y = (tensors[r][c].val[4] * tensors[r][c].val[3] -\n                          tensors[r][c].val[5] * tensors[r][c].val[0]) / denom;\n      }\n      else\n      {\n        output[r][c].x = 0;\n        output[r][c].y = 0;\n      }\n    }\n  }\n}\n\n// top-level sw function\n\nvoid optical_flow(pixel_t frame0[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame1[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame2[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame3[MAX_HEIGHT][MAX_WIDTH],\n                     pixel_t frame4[MAX_HEIGHT][MAX_WIDTH],\n                     velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n#pragma HLS INTERFACE m_axi port=frame0 offset=slave bundle=gmem0\n#pragma HLS INTERFACE m_axi port=frame1 offset=slave bundle=gmem1\n#pragma HLS INTERFACE m_axi port=frame2 offset=slave bundle=gmem2\n#pragma HLS INTERFACE m_axi port=frame3 offset=slave bundle=gmem3\n#pragma HLS INTERFACE m_axi port=frame4 offset=slave bundle=gmem4\n#pragma HLS INTERFACE m_axi port=outputs offset=slave bundle=gmem5\n\n#pragma HLS INTERFACE s_axilite port=return bundle=control\n\n  // intermediate arrays\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n\n  // compute\n  gradient_xy_calc(frame2, gradient_x, gradient_y);\n  gradient_z_calc(frame0, frame1, frame2, frame3, frame4, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n}\n",
        "tgt": "#include \"ap_fixed.h\"\n#include \"ap_int.h\"\n\n// define these constants so they can be used in pragma\nconst int MAX_HEIGHT = 436;\nconst int MAX_WIDTH = 1024;\nconst int max_width = MAX_WIDTH; \nconst int default_depth = MAX_WIDTH;\n\ntypedef ap_fixed<17,9> input_t;\ntypedef ap_fixed<32,13> pixel_t;\ntypedef ap_fixed<32,27> outer_pixel_t;\ntypedef ap_fixed<64,56> calc_pixel_t;\ntypedef ap_fixed<32,13> vel_pixel_t;\n\ntypedef struct{\n\tpixel_t x;\n\tpixel_t y;\n\tpixel_t z;\n}gradient_t;\n\ntypedef struct{\n    outer_pixel_t val[6];\n}outer_t; \n\ntypedef struct{\n    outer_pixel_t val[6];\n}tensor_t;\n\ntypedef struct{\n    vel_pixel_t x;\n    vel_pixel_t y;\n}velocity_t;\n\n// for data packing\ntypedef ap_uint<64> frames_t;\n\n// convolution filters\nconst int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\nconst pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\nconst pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n\nvoid gradient_xy_calc(input_t frame[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  // our own line buffer\n  static pixel_t buf[5][MAX_WIDTH];\n  #pragma HLS array_partition variable=buf complete dim=1\n\n  // small buffer\n  pixel_t smallbuf[5];\n  #pragma HLS array_partition variable=smallbuf complete dim=0\n  \n  // window buffer\n  hls::Window<5,5,input_t> window;\n\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n\n  GRAD_XY_OUTER: for(int r=0; r<MAX_HEIGHT+2; r++)\n  {\n    GRAD_XY_INNER: for(int c=0; c<MAX_WIDTH+2; c++)\n    {\n      #pragma HLS pipeline II=1\n      // read out values from current line buffer\n      for (int i = 0; i < 4; i ++ )\n        smallbuf[i] = buf[i+1][c];\n      // the new value is either 0 or read from frame\n      if (r<MAX_HEIGHT && c<MAX_WIDTH)\n        smallbuf[4] = (pixel_t)(frame[r][c]);\n      else if (c < MAX_WIDTH)\n        smallbuf[4] = 0;\n      // update line buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n      else if(c<MAX_WIDTH)\n      {\n        for (int i = 0; i < 4; i ++ )\n          buf[i][c] = smallbuf[i];\n        buf[4][c] = smallbuf[4];\n      }\n\n      // manage window buffer\n      if(r<MAX_HEIGHT && c<MAX_WIDTH)\n      {\n        window.shift_pixels_left();\n        \n        for (int i = 0; i < 5; i ++ )\n          window.insert_pixel(smallbuf[i],i,4);\n      }\n      else\n      {\n        window.shift_pixels_left();\n        window.insert_pixel(0,0,4);\n        window.insert_pixel(0,1,4);\n        window.insert_pixel(0,2,4);\n        window.insert_pixel(0,3,4);\n        window.insert_pixel(0,4,4);\n      }\n\n      // compute gradient\n      pixel_t x_grad = 0;\n      pixel_t y_grad = 0;\n      if(r>=4 && r<MAX_HEIGHT && c>=4 && c<MAX_WIDTH)\n      {\n        GRAD_XY_XYGRAD: for(int i=0; i<5; i++)\n        {\n          x_grad += window.getval(2,i)*GRAD_WEIGHTS[i];\n          y_grad += window.getval(i,2)*GRAD_WEIGHTS[i];\n        }\n        gradient_x[r-2][c-2] = x_grad/12;\n        gradient_y[r-2][c-2] = y_grad/12;\n      }\n      else if(r>=2 && c>=2)\n      {\n        gradient_x[r-2][c-2] = 0;\n        gradient_y[r-2][c-2] = 0;\n      }\n    }\n  }\n}\n\n// calculate gradient in the z direction\nvoid gradient_z_calc(input_t frame1[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame2[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame3[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame4[MAX_HEIGHT][MAX_WIDTH], \n    input_t frame5[MAX_HEIGHT][MAX_WIDTH], \n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH])\n{\n  const int GRAD_WEIGHTS[] =  {1,-8,0,8,-1};\n  GRAD_Z_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_Z_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_z[r][c] =((pixel_t)(frame1[r][c]*GRAD_WEIGHTS[0] \n                        + frame2[r][c]*GRAD_WEIGHTS[1]\n                        + frame3[r][c]*GRAD_WEIGHTS[2]\n                        + frame4[r][c]*GRAD_WEIGHTS[3]\n                        + frame5[r][c]*GRAD_WEIGHTS[4]))/12;\n    }\n  }\n}\n\n// average the gradient in y direction\nvoid gradient_weight_y(pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH],\n    pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH],\n    gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<7,MAX_WIDTH,gradient_t> buf;\n\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+3; r++)\n  {\n    GRAD_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      #pragma HLS dependence variable=buf inter false\n\n      if(r<MAX_HEIGHT)\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = gradient_x[r][c];\n        tmp.y = gradient_y[r][c];\n        tmp.z = gradient_z[r][c];\n        buf.insert_bottom_row(tmp,c);\n      }\n      else\n      {\n        buf.shift_pixels_up(c);\n        gradient_t tmp;\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;\n        buf.insert_bottom_row(tmp,c);\n      }     \n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(r >= 6 && r<MAX_HEIGHT)\n      { \n        GRAD_WEIGHT_Y_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(i,c).x*GRAD_FILTER[i];\n          acc.y += buf.getval(i,c).y*GRAD_FILTER[i];\n          acc.z += buf.getval(i,c).z*GRAD_FILTER[i];\n        }\n        filt_grad[r-3][c] = acc;\n      }\n      else if(r>=3)\n      {\n        filt_grad[r-3][c] = acc;\n      }\n    }\n  }\n}\n\n// average gradient in the x direction\nvoid gradient_weight_x(gradient_t y_filt[MAX_HEIGHT][MAX_WIDTH],\n                       gradient_t filt_grad[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,7,gradient_t> buf;\n  const pixel_t GRAD_FILTER[] = {0.0755, 0.133, 0.1869, 0.2903, 0.1869, 0.133, 0.0755};\n  GRAD_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    GRAD_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+3; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      gradient_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = y_filt[r][c];\n      }\n      else\n      {\n        tmp.x = 0;\n        tmp.y = 0;\n        tmp.z = 0;  \n      }\n      buf.insert_pixel(tmp,0,6);\n\n      gradient_t acc;\n      acc.x = 0;\n      acc.y = 0;\n      acc.z = 0;\n      if(c >= 6 && c<MAX_WIDTH) \n      {\n        GRAD_WEIGHT_X_ACC: for(int i=0; i<7; i++)\n        {\n          acc.x += buf.getval(0,i).x*GRAD_FILTER[i];\n          acc.y += buf.getval(0,i).y*GRAD_FILTER[i];\n          acc.z += buf.getval(0,i).z*GRAD_FILTER[i];\n        }\n        filt_grad[r][c-3] = acc;\n      }\n      else if(c>=3)\n      {\n        filt_grad[r][c-3] = acc;\n      }\n    }\n  }\n}\n\n// outer product \nvoid outer_product(gradient_t gradient[MAX_HEIGHT][MAX_WIDTH],\n     outer_t outer_product[MAX_HEIGHT][MAX_WIDTH])\n{\n  OUTER_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    OUTER_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      gradient_t grad = gradient[r][c];\n      outer_pixel_t x = (outer_pixel_t) grad.x;\n      outer_pixel_t y = (outer_pixel_t) grad.y;\n      outer_pixel_t z = (outer_pixel_t) grad.z;\n      outer_t out;\n      out.val[0] = (x*x);\n      out.val[1] = (y*y);\n      out.val[2] = (z*z);\n      out.val[3] = (x*y);\n      out.val[4] = (x*z);\n      out.val[5] = (y*z);\n      outer_product[r][c] = out;\n    }\n  }\n}\n\n// tensor weight\nvoid tensor_weight_y(outer_t outer[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::LineBuffer<3,MAX_WIDTH,outer_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_Y_OUTER: for(int r=0; r<MAX_HEIGHT+1; r++)\n  {\n    TENSOR_WEIGHT_Y_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      \n      outer_t tmp;\n      #pragma HLS data_pack variable=tmp\n      #pragma HLS data_pack variable=buf.val[0]\n      buf.shift_pixels_up(c);\n      if(r<MAX_HEIGHT)\n      {\n        tmp = outer[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_Y_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }   \n      buf.insert_bottom_row(tmp,c);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_Y_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n     \n      if (r >= 2 && r < MAX_HEIGHT) \n      {\n        TENSOR_WEIGHT_Y_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(i,c);\n          pixel_t k = TENSOR_FILTER[i];\n          TENSOR_WEIGHT_Y_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*k;\n          }\n        }\n      }\n      if(r >= 1)\n      { \n        tensor_y[r-1][c] = acc;      \n      }\n    }\n  }\n}\n\nvoid tensor_weight_x(tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH],\n                     tensor_t tensor[MAX_HEIGHT][MAX_WIDTH])\n{\n  hls::Window<1,3,tensor_t> buf;\n  const pixel_t TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  //const float TENSOR_FILTER[] = {0.3243, 0.3513, 0.3243};\n  TENSOR_WEIGHT_X_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    TENSOR_WEIGHT_X_INNER: for(int c=0; c<MAX_WIDTH+1; c++)\n    {\n      #pragma HLS pipeline II=1\n      buf.shift_pixels_left();\n      tensor_t tmp;\n      if(c<MAX_WIDTH)\n      {\n        tmp = tensor_y[r][c];\n      }\n      else\n      {\n        TENSOR_WEIGHT_X_TMP_INIT: for(int i=0; i<6; i++)\n          tmp.val[i] = 0;\n      }\n      buf.insert_pixel(tmp,0,2);\n\n      tensor_t acc;\n      TENSOR_WEIGHT_X_ACC_INIT: for(int k =0; k<6; k++)\n        acc.val[k] = 0;\n      if (c >= 2 && c < MAX_WIDTH) \n      {\n        TENSOR_WEIGHT_X_TMP_OUTER: for(int i=0; i<3; i++)\n        {\n          tmp = buf.getval(0,i);\n          TENSOR_WEIGHT_X_TMP_INNER: for(int component=0; component<6; component++)\n          {\n            acc.val[component] += tmp.val[component]*TENSOR_FILTER[i];\n          }\n        }\n      }\n      if(c>=1)\n      {\n        tensor[r][c-1] = acc;\n      }\n    }\n  }\n}\n\n// compute output flow\nvoid flow_calc(tensor_t tensors[MAX_HEIGHT][MAX_WIDTH],\n               velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  static outer_pixel_t buf[2];\n  FLOW_OUTER: for(int r=0; r<MAX_HEIGHT; r++)\n  {\n    FLOW_INNER: for(int c=0; c<MAX_WIDTH; c++)\n    {\n      #pragma HLS pipeline II=1\n      tensor_t tmp_tensor = tensors[r][c];\n      if(r>=2 && r<MAX_HEIGHT-2 && c>=2 && c<MAX_WIDTH-2)\n      {\n\t      calc_pixel_t t1 = (calc_pixel_t) tmp_tensor.val[0];\n\t      calc_pixel_t t2 = (calc_pixel_t) tmp_tensor.val[1];\n\t      calc_pixel_t t3 = (calc_pixel_t) tmp_tensor.val[2];\n\t      calc_pixel_t t4 = (calc_pixel_t) tmp_tensor.val[3];\n\t      calc_pixel_t t5 = (calc_pixel_t) tmp_tensor.val[4];\n\t      calc_pixel_t t6 = (calc_pixel_t) tmp_tensor.val[5];\n\n        calc_pixel_t denom = t1*t2-t4*t4;\n\t      calc_pixel_t numer0 = t6*t4-t5*t2;\n\t      calc_pixel_t numer1 = t5*t4-t6*t1;\n\n\t      if(denom != 0)\n        {\n          buf[0] = numer0 / denom;\n          buf[1] = numer1 / denom;\n\t      } \n\t      else\n\t      {\n\t\t      buf[0] = 0;\n\t\t      buf[1] = 0;\n\t      }\n      }\n      else\n      {\n        buf[0] = buf[1] = 0;\n      }\n\n      outputs[r][c].x = (vel_pixel_t)buf[0];\n      outputs[r][c].y = (vel_pixel_t)buf[1];\n\n    }\n  }\n}\n\n// top-level kernel function\nvoid optical_flow(frames_t   frames[MAX_HEIGHT][MAX_WIDTH],\n                  velocity_t outputs[MAX_HEIGHT][MAX_WIDTH])\n{\n  #pragma HLS data_pack variable=outputs\n\n  #pragma HLS DATAFLOW\n\n  // FIFOs connecting the stages\n  static pixel_t gradient_x[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_x depth=default_depth\n  static pixel_t gradient_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_y depth=default_depth\n  static pixel_t gradient_z[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=gradient_z depth=max_width*4\n  static gradient_t y_filtered[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=y_filtered depth=default_depth\n  static gradient_t filtered_gradient[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=filtered_gradient depth=default_depth\n  static outer_t out_product[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=out_product depth=default_depth\n  #pragma HLS data_pack variable=out_product\n  static tensor_t tensor_y[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor_y depth=default_depth\n  #pragma HLS data_pack variable=tensor_y\n  static tensor_t tensor[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=tensor depth=default_depth\n  #pragma HLS data_pack variable=tensor\n\n  // FIFOs for streaming in, just for clarity\n  static input_t frame1_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame1_a depth=default_depth\n  static input_t frame2_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame2_a depth=default_depth\n  static input_t frame4_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame4_a depth=default_depth\n  static input_t frame5_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame5_a depth=default_depth\n\n  //Need to duplicate frame3 for the two calculations\n  static input_t frame3_a[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame3_a depth=default_depth\n  static input_t frame3_b[MAX_HEIGHT][MAX_WIDTH];\n  #pragma HLS STREAM variable=frame3_b depth=default_depth\n\n  // stream in and organize the inputs\n  static frames_t buf;\n  FRAMES_CP_OUTER: for (int r=0; r<MAX_HEIGHT; r++) \n  {\n    FRAMES_CP_INNER: for (int c=0; c<MAX_WIDTH; c++) \n    {\n      #pragma HLS pipeline II=1\n\n      // one wide read\n      buf = frames[r][c];\n      // assign values to the FIFOs\n      frame1_a[r][c] = ((input_t)(buf(7 ,  0)) >> 8);\n      frame2_a[r][c] = ((input_t)(buf(15,  8)) >> 8);\n      frame3_a[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame3_b[r][c] = ((input_t)(buf(23, 16)) >> 8);\n      frame4_a[r][c] = ((input_t)(buf(31, 24)) >> 8);\n      frame5_a[r][c] = ((input_t)(buf(39, 32)) >> 8);\n    }\n  }\n  //\n  // compute\n  gradient_xy_calc(frame3_a, gradient_x, gradient_y);\n  gradient_z_calc(frame1_a, frame2_a, frame3_b, frame4_a, frame5_a, gradient_z);\n  gradient_weight_y(gradient_x, gradient_y, gradient_z, y_filtered);\n  gradient_weight_x(y_filtered, filtered_gradient);\n  outer_product(filtered_gradient, out_product);\n  tensor_weight_y(out_product, tensor_y);\n  tensor_weight_x(tensor_y, tensor);\n  flow_calc(tensor, outputs);\n\n}\n\n"
    },
    "digitrec": {
        "src": "// dataset information\n#define NUM_TRAINING 18000\n#define CLASS_SIZE 1800\n#define NUM_TEST 2000\n#define DIGIT_WIDTH 4\n\n// typedefs\ntypedef unsigned long long DigitType;\ntypedef unsigned char      LabelType;\n\n// parameters\n#define K_CONST 3\n#define PAR_FACTOR 40\n// types and constants used in the functions below\nconst unsigned long long m1  = 0x5555555555555555; //binary: 0101...\nconst unsigned long long m2  = 0x3333333333333333; //binary: 00110011..\nconst unsigned long long m4  = 0x0f0f0f0f0f0f0f0f; //binary:  4 zeros,  4 ones ...\n\n// popcount function\n// source: wikipedia (https://en.wikipedia.org/wiki/Hamming_weight)\nint popcount(DigitType x)\n{\n   x -= (x >> 1) & m1;             //put count of each 2 bits into those 2 bits\n   x = (x & m2) + ((x >> 2) & m2); //put count of each 4 bits into those 4 bits \n   x = (x + (x >> 4)) & m4;        //put count of each 8 bits into those 8 bits \n   x += x >>  8;  //put count of each 16 bits into their lowest 8 bits\n   x += x >> 16;  //put count of each 32 bits into their lowest 8 bits\n   x += x >> 32;  //put count of each 64 bits into their lowest 8 bits\n   return x & 0x7f;\n}\n\nvoid update_knn( const DigitType* train_inst, const DigitType* test_inst, int dists[K_CONST], int labels[K_CONST], int label ) \n{\n  int dist = 0;\n\n  for (int i = 0; i < DIGIT_WIDTH; i ++ )\n  {\n    DigitType diff = test_inst[i] ^ train_inst[i];\n    dist += popcount(diff);\n  }\n\n  int max_dist = 0;\n  int max_dist_id = K_CONST+1;\n\n  // Find the max distance\n  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k ) \n  {\n    if ( dists[k] > max_dist ) \n    {\n      max_dist = dists[k];\n      max_dist_id = k;\n    }\n  }\n\n  // Replace the entry with the max distance\n  if ( dist < max_dist )\n  {\n    dists[max_dist_id] = dist;\n    labels[max_dist_id] = label;\n  }\n\n  return;\n}\n\nLabelType knn_vote(int labels[K_CONST]) \n{\n  int max_vote = 0;\n  LabelType max_label = 0;\n  \n  int votes[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n\n  for (int i = 0; i < K_CONST; i ++ )\n    votes[labels[i]] ++;\n\n  for (int i = 0; i < 10; i ++ ) \n  {\n    if (votes[i] > max_vote)\n    {\n      max_vote = votes[i];\n      max_label = i;\n    }\n  }\n\n  return max_label;\n\n}\n\n// sw top function\n\nvoid digitrec(const DigitType training_set[NUM_TRAINING * DIGIT_WIDTH], \n                 const DigitType test_set[NUM_TEST * DIGIT_WIDTH], \n                 LabelType results[NUM_TEST]) \n{\n\n  // nearest neighbor set\n  int dists[K_CONST];\n  int labels[K_CONST];\n\n  // loop through test set\n  TEST_LOOP: for (int t = 0; t < NUM_TEST; ++t) \n  {\n    // Initialize the neighbor set\n    SET_KNN_SET: for ( int i = 0; i < K_CONST; ++i ) \n    {\n      // Note that the max distance is 256\n      dists[i] = 256;\n      labels[i] = 0;\n    }\n\n    // for each training instance, compare it with the test instance, and update the nearest neighbor set\n    TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING; ++i ) \n      update_knn(&training_set[i * DIGIT_WIDTH], &test_set[t * DIGIT_WIDTH], dists, labels, i / CLASS_SIZE);\n      \n    // Compute the final output\n    LabelType max_vote = knn_vote(labels);\n    results[t] = max_vote;\n\n  }\n\n}\n\n",
        "tgt": "\n#define NUM_TRAINING 18000\n#define CLASS_SIZE 1800\n#define NUM_TEST 2000\n#define DIGIT_WIDTH 4\n// typedefs\ntypedef unsigned long long DigitType;\ntypedef unsigned char      LabelType;\n\n#include \"ap_int.h\"\n// sdsoc wide vector type\ntypedef ap_uint<256>  WholeDigitType;\n#define K_CONST 3\n#define PAR_FACTOR 40\n\n// popcount function\nint popcount(WholeDigitType x)\n{\n  // most straightforward implementation\n  // actually not bad on FPGA\n  int cnt = 0;\n  for (int i = 0; i < 256; i ++ )\n    cnt = cnt + x[i];\n\n  return cnt;\n}\n\n// Given the test instance and a (new) training instance, this\n// function maintains/updates an array of K minimum\n// distances per training set.\nvoid update_knn( WholeDigitType test_inst, WholeDigitType train_inst, int min_distances[K_CONST] ) \n{\n  #pragma HLS inline\n\n  // Compute the difference using XOR\n  WholeDigitType diff = test_inst ^ train_inst;\n\n  int dist = 0;\n\n  dist = popcount(diff);\n\n  int max_dist = 0;\n  int max_dist_id = K_CONST+1;\n  int k = 0;\n\n  // Find the max distance\n  FIND_MAX_DIST: for ( int k = 0; k < K_CONST; ++k ) \n  {\n    if ( min_distances[k] > max_dist ) \n    {\n      max_dist = min_distances[k];\n      max_dist_id = k;\n    }\n  }\n\n  // Replace the entry with the max distance\n  if ( dist < max_dist )\n    min_distances[max_dist_id] = dist;\n\n  return;\n}\n\n// Given 10xK minimum distance values, this function\n// finds the actual K nearest neighbors and determines the\n// final output based on the most common int represented by\n// these nearest neighbors (i.e., a vote among KNNs).\nLabelType knn_vote( int knn_set[PAR_FACTOR * K_CONST] ) \n{\n  #pragma HLS inline\n\n  // local buffers\n\n  // final K nearest neighbors\n  int min_distance_list[K_CONST];\n  #pragma HLS array_partition variable=min_distance_list complete dim=0\n  // labels for the K nearest neighbors\n  int label_list[K_CONST];\n  #pragma HLS array_partition variable=label_list complete dim=0\n  // voting boxes\n  int vote_list[10];\n  #pragma HLS array_partition variable=vote_list complete dim=0\n\n  int pos = 1000;\n\n  // initialize\n  INIT_1: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS unroll\n    min_distance_list[i] = 256;\n    label_list[i] = 9;\n  }\n\n  INIT_2: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    vote_list[i] = 0;\n  }\n\n  // go through all the lanes\n  // do an insertion sort to keep a sorted neighbor list\n  LANES: for (int i = 0; i < PAR_FACTOR; i ++ )\n  {\n    INSERTION_SORT_OUTER: for (int j = 0; j < K_CONST; j ++ )\n    {\n      #pragma HLS pipeline\n      pos = 1000;\n      INSERTION_SORT_INNER: for (int r = 0; r < K_CONST; r ++ )\n      {\n        #pragma HLS unroll\n        pos = ((knn_set[i*K_CONST+j] < min_distance_list[r]) && (pos > K_CONST)) ? r : pos;\n      }\n\n      INSERT: for (int r = K_CONST ;r > 0; r -- )\n      {\n        #pragma HLS unroll\n        if(r-1 > pos)\n        {\n          min_distance_list[r-1] = min_distance_list[r-2];\n          label_list[r-1] = label_list[r-2];\n        }\n        else if (r-1 == pos)\n        {\n          min_distance_list[r-1] = knn_set[i*K_CONST+j];\n          label_list[r-1] = i / (PAR_FACTOR / 10);\n        }\n      }\n    }\n  }\n\n  // vote\n  INCREMENT: for (int i = 0;i < K_CONST; i ++ )\n  {\n    #pragma HLS pipeline\n    vote_list[label_list[i]] += 1;\n  }\n\n  LabelType max_vote;\n  max_vote = 0;\n\n  // find the maximum value\n  VOTE: for (int i = 0;i < 10; i ++ )\n  {\n    #pragma HLS unroll\n    if(vote_list[i] >= vote_list[max_vote])\n    {\n      max_vote = i;\n    }\n  }\n\n  return max_vote;\n\n}\n\n// top-level hardware function\n// since AXIDMA_SIMPLE interface does not support arrays with size more than 16384 on interface\n// we call this function twice to transfer data\nvoid digitrec(WholeDigitType global_training_set[NUM_TRAINING / 2], WholeDigitType global_test_set[NUM_TEST], LabelType global_results[NUM_TEST], int run) \n{\n\n  // This array stores K minimum distances per training set\n  int knn_set[PAR_FACTOR * K_CONST];\n  #pragma HLS array_partition variable=knn_set complete dim=0\n\n  static WholeDigitType training_set [NUM_TRAINING];\n  // to be used in a pragma\n  const int unroll_factor = PAR_FACTOR;\n  #pragma HLS array_partition variable=training_set block factor=unroll_factor dim=0\n\n  static WholeDigitType test_set     [NUM_TEST];\n  static LabelType results           [NUM_TEST];\n\n  // the first time, just do data transfer and return\n  if (run == 0)\n  {\n    // copy the training set for the first time\n    for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n      #pragma HLS pipeline\n      training_set[i] = global_training_set[i];\n    return;\n  }\n\n  // for the second time\n  for (int i = 0; i < NUM_TRAINING / 2; i ++ )\n    #pragma HLS pipeline\n    training_set[i + NUM_TRAINING / 2] = global_training_set[i];\n  // copy the test set\n  for (int i = 0; i < NUM_TEST; i ++ )\n    #pragma HLS pipeline\n    test_set[i] = global_test_set[i];\n\n  // loop through test set\n  TEST_LOOP: for (int t = 0; t < NUM_TEST; ++t) \n  {\n    // fetch one instance\n    WholeDigitType test_instance = test_set[t];\n\n    // Initialize the knn set\n    SET_KNN_SET: for ( int i = 0; i < K_CONST * PAR_FACTOR ; ++i ) \n    {\n      #pragma HLS unroll\n      // Note that the max distance is 256\n      knn_set[i] = 256;\n    }\n\n    TRAINING_LOOP : for ( int i = 0; i < NUM_TRAINING / PAR_FACTOR; ++i ) \n    {\n      #pragma HLS pipeline\n      LANES : for ( int j = 0; j < PAR_FACTOR; j++ ) \n      {\n        #pragma HLS unroll\n        // Read a new instance from the training set\n        WholeDigitType training_instance = training_set[j * NUM_TRAINING / PAR_FACTOR + i];\n\n        // Update the KNN set\n        update_knn( test_instance, training_instance, &knn_set[j * K_CONST] );\n      }\n    }\n    // Compute the final output\n    LabelType max_vote = knn_vote(knn_set);\n    results[t] = max_vote;\n\n  }\n\n  // copy the results out\n  for (int i = 0; i < NUM_TEST; i ++ )\n    #pragma HLS pipeline\n    global_results[i] = results[i];\n\n}\n\n\n"
    },
    "bfs": {
        "src": "#include <hls_stream.h>\n#include <ap_int.h>\n#include <stdio.h>\n\n// load depth for inspection \nvoid bfs(\n\t\tchar  *depth_for_inspect, \n\t\tchar *depth_for_expand,\n\t\tchar *depth_for_update,\n\t\tconst int *rpao,\n\t\tconst int *ciao,\n\t\tint *frontier_size,\n        int vertex_num,\n\t\tconst char level)\n{\n\tchar d;\n\tint start, end;\n\tint ngb_vidx;\n\tchar ngb_depth;\n\tint counter = 0;\n\tchar level_plus1 = level + 1;\n    for (int i = 0; i < vertex_num; i++){\n        d = depth_for_inspect[i];\n\t\tif(d == level){\n\t\t\tcounter++;\n\t\t\tstart = rpao[i];\n\t\t\tend = rpao[i+1];\n\t\t\tfor(int j = start; j < end; j++){\n            #pragma HLS pipeline\n\t\t\t\tngb_vidx = ciao[j];\n\t\t\t\tngb_depth = depth_for_expand[ngb_vidx];\n\t\t\t\tif(ngb_depth == -1){\n\t\t\t\t\tdepth_for_update[ngb_vidx] = level_plus1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(i == vertex_num - 1){\n\t\t\t*frontier_size = counter;\n\t\t}\n    }\n}\n\n\n",
        "tgt": "#include <hls_stream.h>\n#include <ap_int.h>\n#include <stdio.h>\n\n#define OFFSET 1024\n#define STRIDE 2048\n\ntypedef ap_uint<1> uint1_dt;\ntypedef ap_int<8> int8_dt;\ntypedef ap_int<40> int40_dt;\ntypedef ap_int<64> int64_dt;\n\n// load depth for inspection \nstatic void read_depth(\n\t\tconst char *depth, \n\t\thls::stream<char> &depth_inspect_stream,\n\t\tconst int start_idx,\n        const int vertex_num)\n{\n    for (int i = start_idx; i < vertex_num; i += STRIDE){\n\t\tfor(int j = 0; j < OFFSET; j++){\n        #pragma HLS pipeline\n\t\t\tdepth_inspect_stream << depth[i + j];\n\t\t}\n    }\n}\n\n// inspect depth for frontier \nstatic void frontier_inspect(\n\t\thls::stream<char> &depth_inspect_stream, \n\t\thls::stream<uint1_dt> &inspect_done_stream,\n\t\thls::stream<int> &frontier_stream,\n\t\tconst int start_idx,\n\t\tconst int vertex_num,\n\t\tint *frontier_size,\n\t\tconst char level)\n{\n\tchar data; \n\tint count = 0;\n\tfor (int i = start_idx; i < vertex_num; i += STRIDE){\n\t\tfor(int j = 0; j < OFFSET; j++){\n        #pragma HLS pipeline\n\t\t\tdata = depth_inspect_stream.read();\n\t\t\tif(data == level){\n\t\t\t\tfrontier_stream << (i + j);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(i + STRIDE >= vertex_num){\n\t\t\tinspect_done_stream << 1;\n\t\t\t*frontier_size = count;\n\t\t}\n\t}\n}\n\n// Read rpao of the frontier \nstatic void read_rpao(\n\t\tconst int *rpao,\n\t\thls::stream<int> &frontier_stream,\n\t\thls::stream<uint1_dt> &inspect_done_stream,\n\t\thls::stream<int64_dt> &rpao_stream,\n\t\thls::stream<uint1_dt> &rpao_done_stream)\n{\n\tuint1_dt frontier_empty = 0;\n\tuint1_dt done_empty = 0;\n\tuint1_dt done = 0;\n\tint vidx;\n\tint rpidx;\n\tint64_dt rpitem;\n\twhile((frontier_empty != 1) || (done != 1)){\n#pragma HLS pipeline\n\t\tfrontier_empty = frontier_stream.empty();\n\t    done_empty = inspect_done_stream.empty();\n\n\t\tif(frontier_empty != 1){\n\t\t\tvidx = frontier_stream.read();\n\t\t\trpitem.range(31, 0) = rpao[vidx];\n\t\t\trpitem.range(63, 32) = rpao[vidx+1];\n\t\t\trpao_stream << rpitem;\n\t\t}\n\n\t\tif(done_empty != 1 && frontier_empty == 1){\n\t\t\tdone = inspect_done_stream.read();\n\t\t\trpao_done_stream << 1;\n\t\t}\n\t}\n}\n\n// read ciao\nstatic void read_ciao(\n\t\tconst int *ciao,\n\t\thls::stream<int64_dt> &rpao_stream,\n\t\thls::stream<uint1_dt> &rpao_done_stream,\n\t\thls::stream<int> &ciao_stream,\n\t\thls::stream<uint1_dt> &ciao_done_stream\n\t\t)\n{\n\tuint1_dt rpao_empty = 0;\n\tuint1_dt done_empty = 0;\n\tuint1_dt done = 0;\n\tint start, end;\n\tint64_dt rpitem;\n\twhile((rpao_empty != 1) || (done != 1)){\n\t\trpao_empty = rpao_stream.empty();\n\t\tdone_empty = rpao_done_stream.empty();\n\t\t\n\t\tif(rpao_empty != 1){\n\t\t\trpitem = rpao_stream.read();\n\t\t\tstart = rpitem.range(31, 0);\n\t\t\tend = rpitem.range(63, 32);\n\t\t\tfor(int i = start; i < end; i++){\n#pragma HLS pipeline\n\t\t\t\tciao_stream << ciao[i];\n\t\t\t}\n\t\t}\n\n\t\tif(done_empty != 1 && rpao_empty == 1){\n\t\t\tdone = rpao_done_stream.read();\n\t\t\tciao_done_stream << 1;\n\t\t}\n\t}\n}\n\nstatic void get_ngb_depth(\n\t\tconst char *depth,\n\t\thls::stream<int> &ciao_stream,\n\t\thls::stream<uint1_dt> &ciao_done_stream,\n\t\thls::stream<int> &ngb_stream,\n\t\thls::stream<uint1_dt> &ngb_done_stream\n\t\t){\n\tuint1_dt done = 0;\n\tuint1_dt ciao_empty = 0;\n\tuint1_dt done_empty = 0;\n\tint vidx;\n\tchar d;\n\tint8_dt delay_counter = 0;\n\twhile((ciao_empty != 1) || (done != 1)){\n#pragma HLS pipeline\n\t\tciao_empty = ciao_stream.empty();\n\t\tdone_empty = ciao_done_stream.empty();\n\t\tif(ciao_empty != 1){\n\t\t\tvidx = ciao_stream.read();\n\t\t\td = depth[vidx];\n\t\t\tif(d == -1){\n\t\t\t\tngb_stream << vidx;\n\t\t\t}\n\t\t}\n\n\t\tif(done_empty != 1 && ciao_empty == 1){\n\t\t\tdelay_counter++;\n\t\t\tif(delay_counter == 100){\n\t\t\t\tdone = ciao_done_stream.read();\n\t\t\t\tngb_done_stream << 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n// update depth\nstatic void update_depth(\n\t\tchar *depth,\n\t\thls::stream<int> &ngb_stream,\n\t\thls::stream<uint1_dt> &ngb_done_stream,\n\t\tint level_plus1\n\t\t)\n{\n\tuint1_dt done = 0;\n\tuint1_dt ngb_empty = 0;\n\tuint1_dt done_empty = 0;\n\tint vidx;\n\twhile((ngb_empty != 1) || (done != 1)){\n#pragma HLS pipeline\n\t\tngb_empty = ngb_stream.empty();\n\t\tdone_empty = ngb_done_stream.empty();\n\t\t\n\t\tif(ngb_empty != 1){\n\t\t\tvidx = ngb_stream.read();\n\t\t\tdepth[vidx] = level_plus1;\n\t\t}\n\n\t\tif(done_empty != 1 && ngb_empty == 1){\n\t\t\tdone = ngb_done_stream.read();\n\t\t}\n\t}\n}\n\nextern \"C\" {\nvoid bfs(\n\t\tconst char *depth_for_inspect,\n\t\tint *frontier_size,\n\t\tconst int *rpao,\n\t\tconst int *ciao,\n\t\tconst char *depth_for_expand,\n\t\tchar *depth_for_update,\n\t\tconst int vertex_num,\n\t\tchar level\n\t\t)\n{\n#pragma HLS INTERFACE m_axi port=rpao offset=slave bundle=gmem00\n#pragma HLS INTERFACE m_axi port=ciao offset=slave bundle=gmem10\n#pragma HLS INTERFACE m_axi port=depth_for_inspect offset=slave bundle=gmem20\n#pragma HLS INTERFACE m_axi port=depth_for_expand offset=slave bundle=gmem30\n#pragma HLS INTERFACE m_axi port=depth_for_update offset=slave bundle=gmem40\n#pragma HLS INTERFACE m_axi port=frontier_size offset=slave bundle=gmem50\n#pragma HLS INTERFACE s_axilite port=vertex_num bundle=control\n#pragma HLS INTERFACE s_axilite port=level bundle=control\n#pragma HLS INTERFACE s_axilite port=return bundle=control\n\n\thls::stream<char> depth_inspect_stream;\n\thls::stream<int> frontier_stream;\n\thls::stream<uint1_dt> inspect_done_stream;\n\thls::stream<int64_dt> rpao_stream;\n\thls::stream<uint1_dt> rpao_done_stream;\n\thls::stream<int> ciao_stream;\n\thls::stream<uint1_dt> ciao_done_stream;\n\thls::stream<int> ngb_stream;\n\thls::stream<uint1_dt> ngb_done_stream;\n\n\tchar level_plus1 = level + 1;\n\n#pragma HLS STREAM variable=depth_inspect_stream depth=32\n#pragma HLS STREAM variable=inspect_done_stream depth=4\n#pragma HLS STREAM variable=frontier_stream depth=32\n#pragma HLS STREAM variable=rpao_stream depth=32\n#pragma HLS STREAM variable=rpao_done_stream depth=4\n#pragma HLS STREAM variable=ciao_stream depth=64\n#pragma HLS STREAM variable=ciao_done_stream depth=4\n#pragma HLS STREAM variable=ngb_stream depth=64\n#pragma HLS STREAM variable=ngb_done_stream depth=4\n\n#pragma HLS dataflow\n    read_depth(depth_for_inspect, depth_inspect_stream, 0, vertex_num);\n\n\tfrontier_inspect(depth_inspect_stream, inspect_done_stream, \n\t\t\tfrontier_stream, 0, vertex_num, frontier_size, level);\n\n\tread_rpao(rpao, frontier_stream, inspect_done_stream, rpao_stream, rpao_done_stream);\n\n\tread_ciao(ciao, rpao_stream, rpao_done_stream, ciao_stream, ciao_done_stream);\n\n\tget_ngb_depth(depth_for_expand, ciao_stream, ciao_done_stream, ngb_stream, ngb_done_stream);\n\n    update_depth(depth_for_update, ngb_stream, ngb_done_stream, level_plus1);\n}\n}\n"
    },
    "linear_search": {
        "src": "#include <cmath>\n#include <limits>\n#include <stdio.h>\n\n#define TARGETS 3000\n#define QUERIES 1000\n#define DIMS 3\n\nfloat compute_distance(float target[DIMS], float query[DIMS]) {\n    float dist = 0.0f;\n    for (int i = 0; i < DIMS; i++) {\n        float diff = target[i] - query[i];\n        dist += diff * diff;\n    }\n    return dist;\n}\n\nvoid linear_search(float* targets, float* queries, unsigned int indices[QUERIES]) {\n    for (int q = 0; q < QUERIES; q++) {\n        float min_dist = std::numeric_limits<float>::max();\n        unsigned int min_index = 0;\n        \n        for (int t = 0; t < TARGETS; t++) {\n            float dist = compute_distance(targets[t], queries[q]);\n            if (dist < min_dist) {\n                min_dist = dist;\n                min_index = t;\n            }\n        }\n        \n        indices[q] = min_index;\n    }\n}\n",
        "tgt": "\n#include <ap_int.h>\n#include <float.h>\n#include <math.h>\n#include <stdio.h>\n\n#define TARGETS 3000\n#define QUERIES 1000\n#define DIMS 3\n\n#ifndef COMPUTE_TARGETS\n#define COMPUTE_TARGETS (16)\n#endif\n\n#ifndef COMPUTE_QUERIES\n#define COMPUTE_QUERIES (16)\n#endif\n\n#define QUERY_BLOCKS ((QUERIES - 1) / COMPUTE_QUERIES + 1)\n#define TARGET_BLOCKS ((TARGETS - 1) / COMPUTE_TARGETS + 1)\n\ntypedef ap_ufixed<38, 20> diff_t;\n\ndiff_t linear_search_compute_elem(unsigned int target_x,\n                                  unsigned int target_y,\n                                  unsigned int target_z,\n                                  unsigned int query_x,\n                                  unsigned int query_y,\n                                  unsigned int query_z) {\n   #pragma HLS INLINE\n\n    ap_fixed<32, 16> target_x_fixed, target_y_fixed, target_z_fixed, query_x_fixed, query_y_fixed, query_z_fixed;\n    target_x_fixed.range(31, 0) = target_x;\n    target_y_fixed.range(31, 0) = target_y;\n    target_z_fixed.range(31, 0) = target_z;\n    query_x_fixed.range(31, 0) = query_x;\n    query_y_fixed.range(31, 0) = query_y;\n    query_z_fixed.range(31, 0) = query_z;\n\n    ap_fixed<17, 8, AP_TRN, AP_SAT> target_x_trn, target_y_trn, target_z_trn, query_x_trn, query_y_trn, query_z_trn;\n    target_x_trn = target_x_fixed;\n    target_y_trn = target_y_fixed;\n    target_z_trn = target_z_fixed;\n    query_x_trn = query_x_fixed;\n    query_y_trn = query_y_fixed;\n    query_z_trn = query_z_fixed;\n\n    ap_fixed<18, 9, AP_TRN> dist_x, dist_y, dist_z;\n    dist_x = target_x_trn - query_x_trn;\n    dist_y = target_y_trn - query_y_trn;\n    dist_z = target_z_trn - query_z_trn;\n\n    #pragma HLS RESOURCE variable=dist_x core=AddSub_DSP\n    #pragma HLS RESOURCE variable=dist_y core=AddSub_DSP\n    #pragma HLS RESOURCE variable=dist_z core=AddSub_DSP\n\n    ap_ufixed<36, 18, AP_TRN> pair_dist_x, pair_dist_y, pair_dist_z;\n    pair_dist_x = dist_x * dist_x;\n    pair_dist_y = dist_y * dist_y;\n    pair_dist_z = dist_z * dist_z;\n\n    diff_t pair_dist = pair_dist_x;\n    pair_dist += pair_dist_y;\n    pair_dist += pair_dist_z;\n    #pragma HLS RESOURCE variable=pair_dist core=AddSub_DSP\n\n    return pair_dist;\n}\n\nvoid linear_search_compute(\n\n    unsigned int targets[TARGET_BLOCKS][COMPUTE_TARGETS][DIMS],\n    unsigned int queries[QUERY_BLOCKS][COMPUTE_QUERIES][DIMS],\n    unsigned int indices[QUERY_BLOCKS][COMPUTE_QUERIES]\n\n) {\n   #pragma HLS INLINE\n\n    diff_t dists[QUERY_BLOCKS][COMPUTE_QUERIES];\n    #pragma HLS ARRAY_PARTITION variable=dists complete dim=2\n\nCOMPUTE_LOOP:\n    for (size_t i = 0; i < TARGET_BLOCKS * QUERY_BLOCKS; i++) {\n        {\n            size_t t = i / QUERY_BLOCKS;\n            size_t q = i % QUERY_BLOCKS;\n           #pragma HLS PIPELINE II=1\n\n            diff_t ldists[COMPUTE_QUERIES][COMPUTE_TARGETS];\n           #pragma HLS ARRAY_PARTITION variable=ldists complete dim=0\n\n            diff_t min_dist[COMPUTE_QUERIES];\n            unsigned int min_indices[COMPUTE_QUERIES];\n           #pragma HLS ARRAY_PARTITION variable=min_dist complete\n           #pragma HLS ARRAY_PARTITION variable=min_indices complete\n\n            for (size_t j = 0; j < COMPUTE_QUERIES; j++) {\n                if (t == 0) {\n                    min_dist[j].range(37, 0) = 0x3FFFFFFFFL;\n                    min_indices[j] = -1;\n                } else {\n                    min_dist[j] = dists[q][j];\n                    min_indices[j] = indices[q][j];\n                }\n            }\n\n            unsigned int lqueries[COMPUTE_QUERIES][DIMS];\n           #pragma HLS ARRAY_PARTITION variable=lqueries complete dim=0\n\n            for (size_t j = 0; j < COMPUTE_QUERIES; j++) {\n                for (size_t k = 0; k < DIMS; k++) {\n                    lqueries[j][k] = queries[q][j][k];\n                }\n            }\n\n            unsigned int ltargets[COMPUTE_TARGETS][DIMS];\n           #pragma HLS ARRAY_PARTITION variable=ltargets complete dim=0\n\n            for (size_t j = 0; j < COMPUTE_TARGETS; j++) {\n               #pragma HLS UNROLL\n                for (size_t k = 0; k < DIMS; k++) {\n                   #pragma HLS UNROLL\n                    ltargets[j][k] = targets[t][j][k];\n                }\n            }\n\n            for (size_t j = 0; j < COMPUTE_QUERIES; j++) {\n                for (size_t k = 0; k < COMPUTE_TARGETS; k++) {\n                    if (t * COMPUTE_TARGETS + k < TARGETS &&\n                        q * COMPUTE_QUERIES + j < QUERIES) {\n                        ldists[j][k] =\n                            linear_search_compute_elem(ltargets[k][0],\n                                                       ltargets[k][1],\n                                                       ltargets[k][2],\n                                                       lqueries[j][0],\n                                                       lqueries[j][1],\n                                                       lqueries[j][2]);\n                    } else {\n                        /* Set to positive infinity */\n                        ldists[j][k].range(37, 0) = 0x3FFFFFFFFFL;\n                    }\n                }\n            }\n\n            for (size_t j = 0; j < COMPUTE_QUERIES; j++) {\n                for (size_t k = 0; k < COMPUTE_TARGETS; k++) {\n                    if (ldists[j][k] < min_dist[j]) {\n                        min_dist[j] = ldists[j][k];\n                        min_indices[j] = t * COMPUTE_TARGETS + k;\n                    }\n                }\n            }\n\n            for (size_t j = 0; j < COMPUTE_QUERIES; j++) {\n                dists[q][j] = min_dist[j];\n                indices[q][j] = min_indices[j];\n            }\n        }\n    }\n}\n\nvoid linear_search(float *targets, float *queries, unsigned int *indices) {\n\n    unsigned int queries_buf[QUERY_BLOCKS][COMPUTE_QUERIES][DIMS];\n    #pragma HLS ARRAY_PARTITION variable = queries_buf complete dim = 2\n    #pragma HLS ARRAY_PARTITION variable = queries_buf complete dim = 3\n\n\nQUERIES_LOOP:\n    for (size_t i = 0; i < QUERIES * DIMS; i++) {\n       #pragma HLS PIPELINE II=1\n        size_t x = i % DIMS;\n        size_t y = (i / DIMS) % COMPUTE_QUERIES;\n        size_t z = i / DIMS / COMPUTE_QUERIES;\n        ap_fixed<32, 16, AP_TRN, AP_SAT> tfixed = queries[i];\n        queries_buf[z][y][x] = tfixed.range(31, 0);\n    }\n\n    unsigned int targets_buf[TARGET_BLOCKS][COMPUTE_TARGETS][DIMS];\n    #pragma HLS ARRAY_PARTITION variable = targets_buf complete dim = 2\n    #pragma HLS ARRAY_PARTITION variable = targets_buf complete dim = 3\n\n\nTARGETS_LOOP:\n    for (size_t i = 0; i < TARGETS * DIMS; i++) {\n       #pragma HLS PIPELINE II=1\n        size_t x = i % DIMS;\n        size_t y = (i / DIMS) % COMPUTE_TARGETS;\n        size_t z = i / DIMS / COMPUTE_TARGETS;\n        ap_fixed<32, 16, AP_TRN, AP_SAT> tfixed = targets[i];\n        targets_buf[z][y][x] = tfixed.range(31, 0);\n    }\n\n    unsigned int indices_buf[QUERY_BLOCKS][COMPUTE_QUERIES];\n#pragma HLS ARRAY_PARTITION variable = indices_buf complete dim = 2\n\n\n    linear_search_compute(targets_buf, queries_buf, indices_buf);\n\nINDICES_LOOP:\n    for (size_t i = 0; i < QUERIES; i++) {\n       #pragma HLS PIPELINE II=1\n        size_t x = i % COMPUTE_QUERIES;\n        size_t y = i / COMPUTE_QUERIES;\n        indices[i] = indices_buf[y][x];\n    }\n}\n\n"
    },
    "sobel": {
        "src": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define WIDTH 64\n#define HEIGHT 64\n\n//#define OUTPUT_DEBUG\nvoid sobel(int *inputImage, int *outputImage,int EDGE_THRESHOLD) {\n#pragma HLS INTERFACE m_axi depth=4096 port=outputImage offset=slave bundle=out\n#pragma HLS INTERFACE m_axi depth=4096 port=inputImage offset=slave bundle=in\n//#pragma HLS INTERFACE ap_ctrl_none port=return\n\n\tint image_data[WIDTH+2][WIDTH+2];\n#pragma HLS RESOURCE variable=image_data core=RAM_2P_BRAM\nIMG_CREATE:\n    for(int p = 0 ; p < WIDTH+2 ; p++){\n        for(int q = 0 ; q < WIDTH +2 ; q++){\n            if( p ==0 || q ==0 || p ==WIDTH+1 || q ==WIDTH+1)\n                image_data[p][q]=0;\n            else\n                image_data[p][q] = inputImage[(q-1)+(p-1)*WIDTH];\n            }\n    }\n\n    int Gx[WIDTH][WIDTH];\n#pragma HLS RESOURCE variable=Gx core=RAM_2P_LUTRAM\n    int Gy[WIDTH][WIDTH];\n#pragma HLS RESOURCE variable=Gy core=RAM_2P_LUTRAM\nOUTPUT_CREATE:\n    for(int i = 1 ; i < WIDTH+1 ; i++){\n        for(int j = 1 ; j < WIDTH+1 ; j++){\n            Gx[i-1][j-1] = (image_data[i-1][j-1] + 2* image_data[i-1][j] + image_data[i-1][j+1]) - (image_data[i+1][j-1] + 2* image_data[i+1][j] + image_data[i+1][j+1]);\n            Gy[i-1][j-1] = (image_data[i-1][j-1] + 2* image_data[i][j-1] + image_data[i+1][j-1]) - (image_data[i-1][j+1] + 2* image_data[i][j+1] + image_data[i+1][j+1]);\n            int gradient = (int)sqrt(Gx[i-1][j-1] * Gx[i-1][j-1] + Gy[i-1][j-1] * Gy[i-1][j-1]);\n            if (gradient > EDGE_THRESHOLD) {\n                outputImage[(j-1)+WIDTH*(i-1)] = 255;  \n            } else {\n                outputImage[(j-1)+WIDTH*(i-1)] = 0;    \n            }\n        }\n    }\n}\n",
        "tgt": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdint.h>\n\n#define WIDTH 64\n#define HEIGHT 64\n\ntypedef uint8_t data_t;\n\nvoid sobel(int *inputImage, int *outputImage, int EDGE_THRESHOLD) {\n    \n    data_t lineBuffer1[WIDTH+2];\n#pragma HLS RESOURCE variable=lineBuffer1 core=RAM_2P_BRAM\n    data_t lineBuffer2[WIDTH+2];\n#pragma HLS RESOURCE variable=lineBuffer2 core=RAM_2P_BRAM\n    data_t pixelWindow[3][3];\n#pragma HLS ARRAY_PARTITION variable=pixelWindow complete dim=1\n#pragma HLS ARRAY_PARTITION variable=pixelWindow complete dim=2\n\n    // Process the image row by row\n    for (int row = 0; row < HEIGHT; row++) {\n        for (int col = 0; col < WIDTH + 2; col++) {\n            data_t newPixel;\n            \n            // Read new pixel (handle padding for the first and last column)\n            if (col == 0 || col == WIDTH + 1) {\n                newPixel = 0;\n            } else {\n                newPixel = inputImage[row * WIDTH + (col - 1)];\n            }\n\n            // Update pixel window\n            pixelWindow[0][0] = pixelWindow[0][1];\n            pixelWindow[0][1] = pixelWindow[0][2];\n            pixelWindow[0][2] = lineBuffer1[col];\n            pixelWindow[1][0] = pixelWindow[1][1];\n            pixelWindow[1][1] = pixelWindow[1][2];\n            pixelWindow[1][2] = lineBuffer2[col];\n            pixelWindow[2][0] = pixelWindow[2][1];\n            pixelWindow[2][1] = pixelWindow[2][2];\n            pixelWindow[2][2] = newPixel;\n\n            // Update line buffers\n            lineBuffer1[col] = lineBuffer2[col];\n            lineBuffer2[col] = newPixel;\n\n            // Apply Sobel filter if within valid pixel range\n            if (col > 0 && col < WIDTH + 1 && row > 0) {\n                int Gx = (pixelWindow[0][0] + 2 * pixelWindow[0][1] + pixelWindow[0][2]) -\n                         (pixelWindow[2][0] + 2 * pixelWindow[2][1] + pixelWindow[2][2]);\n                int Gy = (pixelWindow[0][0] + 2 * pixelWindow[1][0] + pixelWindow[2][0]) -\n                         (pixelWindow[0][2] + 2 * pixelWindow[1][2] + pixelWindow[2][2]);\n\n                int gradient = (int)(abs(Gx) + abs(Gy));\n\n                // Apply thresholding\n                if (gradient >= EDGE_THRESHOLD) {\n                    gradient = 255;\n                }\n\n                // Store the result (excluding padding)\n                outputImage[(row - 1) * WIDTH + (col - 1)] = gradient;\n            }\n        }\n    }\n}\n"
    },
    "mac_accel": {
        "src": "#ifndef MMULT_H_\n#define MMULT_H_\n#define DATA_SIZE 12\n#define MAX_SIZE 12\n\nvoid mac_accel(\n    const int *a,   // Read-only Matrix A\n    const int *b,   // Read-only Matrix B\n    int *c,         // Output Matrix C\n    int a_row,      // Number of rows in Matrix A\n    int a_col,      // Number of columns in Matrix A (and rows in Matrix B)\n    int b_col       // Number of columns in Matrix B\n) {\n    // Local arrays for storing input and output matrices\n    int localA[MAX_SIZE][MAX_SIZE];\n    int localB[MAX_SIZE][MAX_SIZE];\n    int localC[MAX_SIZE][MAX_SIZE];\n\n    // Load Matrix A from external memory into local array\n    for (int i = 0; i < a_row; i++) {\n        for (int j = 0; j < a_col; j++) {\n            localA[i][j] = a[i * a_col + j];\n        }\n    }\n\n    // Load Matrix B from external memory into local array\n    for (int i = 0; i < a_col; i++) {\n        for (int j = 0; j < b_col; j++) {\n            localB[i][j] = b[i * b_col + j];\n        }\n    }\n\n    // Initialize local output matrix C to 0\n    for (int i = 0; i < a_row; i++) {\n        for (int j = 0; j < b_col; j++) {\n            localC[i][j] = 0;\n        }\n    }\n\n    // Perform matrix multiplication (MAC)\n        for (int j = 0; j < b_col; j++) {\n            for (int k = 0; k < a_col; k++) {\n                localC[i][j] += localA[i][k] * localB[k][j];\n            }\n        }\n\n    // Write the computed result back to external memory\n    for (int i = 0; i < a_row; i++) {\n        for (int j = 0; j < b_col; j++) {\n            c[i * b_col + j] = localC[i][j];\n        }\n    }\n}\n\n",
        "tgt": "\n// Array Size to access\n#define DATA_SIZE 12\n// Maximum Array Size\n#define MAX_SIZE 12\n//TRIPCOUNT identifier\nconst unsigned int c_dim = DATA_SIZE;\nvoid mac_accel(\n                const int *a,   // Read-Only Matrix A\n                const int *b,   // Read-Only Matrix B\n                int *c,         // Output Result\n                int a_row,      // Matrix A Row Size\n                int a_col,      // Matrix A Col Size\n                int b_col       // Matrix B Col Size\n                )\n{\n    int b_row = a_col;\n    int c_row = a_row;\n    int c_col = b_col;\n\n    // Local memory to store input and output matrices\n    int localA[MAX_SIZE][MAX_SIZE];\n    #pragma HLS ARRAY_PARTITION variable=localA dim=1 complete\n\n    int localB[MAX_SIZE][MAX_SIZE];\n    #pragma HLS ARRAY_PARTITION variable=localB dim=2 complete\n\n    int localC[MAX_SIZE][MAX_SIZE];\n    #pragma HLS ARRAY_PARTITION variable=localC dim=0 complete\n\n    // Burst reads on input matrices from DDR memory\n    // Read Input \n    read: for(int loc = 0, i = 0, j = 0; loc < a_row*a_col; loc++, j++) {\n    #pragma HLS LOOP_TRIPCOUNT min=c_dim*c_dim max=c_dim*c_dim\n    #pragma HLS PIPELINE\n        if(j == a_col) { i++; j = 0;}\n        localA[i][j] = a[loc];\n        localB[i][j] = b[loc];\n    }\n\n    // Perform systolic matrix multiply\n    // local matrices localA and localB have been partitioned in dimensions\n    // 1 and 2 respectively. local matrix C has been partitioned completely\n\n    // This partitioning enables to access MAX_SIZE elements in parallel in\n    // the local matrices. Because of the mode of access of array elements,\n    // we are able to perform MAX_SIZE*MAX_SIZE operations in parallel.\n\n    // Note : i, j and k loops are interchanged.\n\n    // The top loop systolic1 runs only for a_col iterations instead of\n    // MAX_SIZE like the inner loops. The inner loops have fixed loop\n    // iteration counts to enable complete unroll\n\n    // The following diagram explains how the matrix multiply happens\n    //\n    //        B_0        B_1        B_2        B_3\n    //         |          |          |          |\n    //         v          v          v          v\n    //        ___        ___        ___        ___\n    //       |   |      |   |      |   |      |   |\n    //  A0_->|C00| ---- |C01| ---- |C02| ---- |C03|\n    //       |___|      |___|      |___|      |___|\n    //         |          |          |          |\n    //        ___        ___        ___        ___\n    //       |   |      |   |      |   |      |   |\n    //  A1_->|C10| ---- |C11| ---- |C12| ---- |C13|\n    //       |___|      |___|      |___|      |___|\n    //         |          |          |          |\n    //        ___        ___        ___        ___\n    //       |   |      |   |      |   |      |   |\n    //  A2_->|C20| ---- |C21| ---- |C21| ---- |C21|\n    //       |___|      |___|      |___|      |___|\n    //         |          |          |          |\n    //        ___        ___        ___        ___\n    //       |   |      |   |      |   |      |   |\n    //  A3_->|C30| ---- |C31| ---- |C32| ---- |C33|\n    //       |___|      |___|      |___|      |___|\n\n    systolic1: for(int k = 0; k < a_col; k++) {\n    #pragma HLS LOOP_TRIPCOUNT min=c_dim max=c_dim\n    #pragma HLS PIPELINE\n        systolic2: for(int i = 0; i < MAX_SIZE; i++) {\n            systolic3: for(int j = 0; j < MAX_SIZE; j++) {\n\n                // Get previous sum\n                int last = (k==0) ? 0 : localC[i][j];\n\n                // Update current sum\n                // Handle boundary conditions\n                int a_val = (i < a_row && k < a_col)? localA[i][k] : 0;\n                int b_val = (k < b_row && j < b_col)? localB[k][j] : 0;\n                int result = last + a_val*b_val;\n\n                // Write back results\n                localC[i][j] = result;\n            }\n        }\n    }\n\n    // Burst write from output matrices to DDR memory\n    // Burst write from matrix C\n    writeC: for(int loc = 0, i = 0, j = 0; loc < c_row*c_col; loc++, j++) {\n    #pragma HLS LOOP_TRIPCOUNT min=c_dim*c_dim max=c_dim*c_dim\n    #pragma HLS PIPELINE\n        if(j == c_col) { i++; j = 0; }\n        c[loc] = localC[i][j];\n    }\n}\n"
    },
    "smithwaterman": {
        "src": "/**********\nCopyright (c) 2018, Xilinx, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software\nwithout specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********/\n#include \"assert.h\"\n#include \"sw.h\"\n#include <ap_int.h>\n#include <stdio.h>\n#include <string.h>\ntypedef ap_uint<2> uint2_t;\ntypedef ap_uint<1> uint1_t;\n\nvoid simpleSW(uint2_t refSeq[MAXCOL],\n              uint2_t readSeq[MAXROW],\n              short *maxr,\n              short *maxc,\n              short *maxv) {\n#pragma HLS inline region off\n    *maxv = MINVAL;\n    int row, col;\n    short mat[MAXROW][MAXCOL];\n    for (col = 0; col < MAXCOL; col++) {\n        short d = refSeq[col];\n        for (row = 0; row < MAXROW; ++row) {\n            short n, nw, w;\n            if (row == 0) {\n                n = 0;\n            } else {\n                n = mat[row - 1][col];\n            }\n            if (col == 0) {\n                w = 0;\n            } else {\n                w = mat[row][col - 1];\n            }\n\n            if (row > 0 && col > 0) {\n                nw = mat[row - 1][col - 1];\n            } else {\n                nw = 0;\n            }\n\n            short q = readSeq[row];\n            short max = 0;\n            short match = (d == q) ? MATCH : MISS_MATCH;\n            short t1 = (nw + match > max) ? nw + match : max;\n            short t2 = (n + GAP > w + GAP) ? n + GAP : w + GAP;\n            max = t1 > t2 ? t1 : t2;\n            mat[row][col] = max;\n            if (max > *maxv) {\n                *maxv = max;\n                *maxr = row;\n                *maxc = col;\n            }\n        }\n    }\n}\n\nvoid sw(uint2_t d[MAXCOL],\n        uint2_t q[MAXROW],\n        short *maxr,\n        short *maxc,\n        short *maxv) {\n#pragma HLS inline region off\n    simpleSW(d, q, maxr, maxc, maxv);\n}\n\ntemplate <int BUFFERSZ>\nvoid intTo2bit(unsigned int *buffer, uint2_t *buffer2b) {\n    int i, j;\n#pragma HLS PIPELINE\n    for (i = 0; i < BUFFERSZ; ++i) {\n        for (j = 0; j < 16; ++j) {\n            buffer2b[16 * i + j] = (buffer[i] & (3 << (2 * j))) >> (2 * j);\n        }\n    }\n}\n\ntemplate <int FACTOR>\nvoid swInt(unsigned int *readRefPacked, short *maxr, short *maxc, short *maxv) {\n#pragma HLS function_instantiate variable = maxv\n    uint2_t d2bit[MAXCOL];\n    uint2_t q2bit[MAXROW];\n#pragma HLS array partition variable = d2bit cyclic factor = FACTOR\n#pragma HLS array partition variable = q2bit cyclic factor = FACTOR\n\n    intTo2bit<MAXCOL / 16>((readRefPacked + MAXROW / 16), d2bit);\n    intTo2bit<MAXROW / 16>(readRefPacked, q2bit);\n    sw(d2bit, q2bit, maxr, maxc, maxv);\n}\n\nvoid swMaxScore(unsigned int readRefPacked[NUMPACKED][PACKEDSZ],\n                short out[NUMPACKED][3]) {\n    /*instantiate NUMPACKED PE*/\n    for (int i = 0; i < NUMPACKED; ++i) {\n       #pragma HLS UNROLL\n        swInt<MAXPE>(readRefPacked[i], &out[i][0], &out[i][1], &out[i][2]);\n    }\n}\n//#ifndef HLS_COMPILE\nextern \"C\" {\n//#endif\nvoid opencl_sw_maxscore(unsigned int *input, unsigned int *output, int *size) {\n#pragma HLS inline region off\n#pragma HLS INTERFACE m_axi port = input offset = slave bundle = gmem\n#pragma HLS INTERFACE m_axi port = output offset = slave bundle = gmem\n#pragma HLS INTERFACE m_axi port = size offset = slave bundle = gmem\n#pragma HLS INTERFACE s_axilite port = input bundle = control\n#pragma HLS INTERFACE s_axilite port = output bundle = control\n#pragma HLS INTERFACE s_axilite port = size bundle = control\n#pragma HLS INTERFACE s_axilite port = return bundle = control\n    unsigned int inbuf[PACKEDSZ * NUMPACKED];\n    unsigned int outbuf[3 * NUMPACKED];\n    unsigned int readRefPacked[NUMPACKED][PACKEDSZ];\n    short out[NUMPACKED][3];\n    int numIter;\n#pragma HLS array partition variable = readRefPacked dim = 1\n#pragma HLS array partition variable = out dim = 0\n    numIter = *size;\n    int loop = 0;\n    for (loop = 0; loop < numIter; loop++) {\n        /*read from device memory to BRAM*/\n        memcpy(readRefPacked,\n               (unsigned int *)(input + loop * PACKEDSZ * NUMPACKED),\n               UINTSZ * PACKEDSZ * NUMPACKED);\n        swMaxScore(readRefPacked, out);\n        /*PE OUT to outbuf*/\n        for (int i = 0; i < NUMPACKED; ++i) {\n#pragma HLS PIPELINE\n            outbuf[3 * i] = out[i][0];\n            outbuf[3 * i + 1] = out[i][1];\n            outbuf[3 * i + 2] = out[i][2];\n        }\n        /*outbuf to device memory*/\n        memcpy((unsigned int *)(output + 3 * NUMPACKED * loop),\n               outbuf,\n               sizeof(unsigned int) * 3 * NUMPACKED);\n    }\n    return;\n}\n}\n",
        "tgt": "/**********\nCopyright (c) 2018, Xilinx, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\nthis list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\nthis list of conditions and the following disclaimer in the documentation\nand/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its contributors\nmay be used to endorse or promote products derived from this software\nwithout specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\nIN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\nINCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\nHOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\nEVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n**********/\n\n/*\n * Systolic implementation of smith-waterman\n */\n\n#include \"assert.h\"\n#include \"sw.h\"\n#include <ap_int.h>\n#include <stdio.h>\n#include <string.h>\n\ntypedef ap_uint<2> uint2_t;\ntypedef ap_uint<1> uint1_t;\n\ntypedef struct _pe {\n    short d;\n    short p;\n} pe;\n\nvoid initPE(pe *pex) {\n#pragma HLS PIPELINE II = 1\n    for (int i = 0; i < MAXPE; i++) {\n        pex[i].d = 0;\n        pex[i].p = 0;\n    }\n}\n\n#ifdef _COMPUTE_FULL_MATRIX\nshort **localMat;\nstatic short colIter = 0;\n#endif\n\nvoid updatePE(pe *pex,\n              uint2_t d,\n              uint2_t q,\n              short n,\n              short nw,\n              short w,\n              short r,\n              short c) {\n#pragma HLS PIPELINE II = 1\n    short max = 0;\n    short match = (d == q) ? MATCH : MISS_MATCH;\n    short x1 = nw + match;\n    short t1 = (x1 > max) ? x1 : max;\n    short x2 = w + GAP;\n    short t2 = (x2 > t1) ? x2 : t1;\n    short x3 = n + GAP;\n    max = (x3 > t2) ? x3 : t2;\n    pex->p = max;\n    pex->d = n;\n#ifdef _COMPUTE_FULL_MATRIX\n    localMat[r][colIter * MAXPE + c] = max;\n#endif\n}\n\nvoid executePE(short r, short c, pe *pex, pe *ppex, uint2_t *d, uint2_t *q) {\n#pragma HLS PIPELINE II = 1\n    short nw, w, n;\n\n    if (r == 0) {\n        n = 0;\n        nw = 0;\n    } else {\n        n = pex->p;\n        nw = ppex->d;\n    }\n    w = ppex->p;\n    uint2_t d1 = d[c];\n    uint2_t q1 = q[r];\n    updatePE(pex, d1, q1, n, nw, w, r, c);\n}\n\nvoid executeFirstPE(\n    short r, short c, pe *p, uint2_t *d, uint2_t *q, short nw, short w) {\n#pragma HLS PIPELINE II = 1\n    short n;\n    if (r == 0) {\n        n = 0;\n    } else {\n        n = p->p;\n    }\n    uint2_t d1 = d[c];\n    uint2_t q1 = q[r];\n    updatePE(p, d1, q1, n, nw, w, r, c);\n}\n\ntemplate <int FACTOR>\nvoid swCoreB(uint2_t *d,\n             uint2_t *q,\n             short *maxr,\n             short *maxc,\n             short *maxv,\n             short *iterB,\n             pe *myPE,\n             short stripe,\n             short rows) {\n#pragma HLS inline\n#pragma HLS array partition variable = d cyclic factor = FACTOR\n    int i, loop;\n    short w = 0; // Initial condition at the start of a row\n    d += stripe * MAXPE;\n    initPE(myPE);\n    for (loop = 0; loop < rows; ++loop) {\n       #pragma HLS PIPELINE II=1\n        short rowmaxv = MINVAL;\n        short rowmaxpe = 0;\n        for (i = 0; i < MAXPE; i++) {\n           #pragma HLS inline region recursive\n            if (i == 0) {\n                short nw = w;\n                w = (stripe == 0) ? 0 : iterB[loop];\n                executeFirstPE(loop, i, &myPE[i], d, q, nw, w);\n            } else {\n                executePE(loop, i, &myPE[i], &myPE[i - 1], d, q);\n            }\n            if (i == MAXPE - 1) {\n                iterB[loop] = myPE[i].p;\n            }\n            if (myPE[i].p > rowmaxv) {\n                rowmaxv = myPE[i].p;\n                rowmaxpe = i;\n            }\n        }\n\n        if (rowmaxv > *maxv) {\n            *maxv = rowmaxv;\n            *maxc = rowmaxpe + stripe * MAXPE; // log2(MAXPE);\n            *maxr = loop;\n        }\n    }\n}\n\n/*Only columns*/\nvoid swSystolicBlocking(uint2_t d[MAXCOL],\n                        uint2_t q[MAXROW],\n                        short *maxr,\n                        short *maxc,\n                        short *maxv,\n                        short rows,\n                        short cols) {\n    pe myPE[MAXPE];\n    short iterB[MAXROW];\n#pragma HLS inline\n#pragma HLS RESOURCE variable = iterB core = RAM_S2P_LUTRAM\n#pragma HLS RESOURCE variable = q core = RAM_S2P_LUTRAM\n    *maxc = MINVAL;\n    *maxv = MINVAL;\n    *maxr = MINVAL;\n    short stripes = MAXCOL / MAXPE;\n    assert(stripes <= (MAXCOL + MAXPE - 1) / MAXPE);\n    assert(rows <= MAXROW);\n#pragma HLS array partition variable = myPE\n    for (short stripe = 0; stripe < stripes; stripe = stripe + 1) {\n#ifdef _COMPUTE_FULL_MATRIX\n        colIter = stripe;\n#endif\n        swCoreB<MAXPE>(d, q, maxr, maxc, maxv, iterB, myPE, stripe, rows);\n    }\n}\n\nvoid simpleSW(uint2_t refSeq[MAXCOL],\n              uint2_t readSeq[MAXROW],\n              short *maxr,\n              short *maxc,\n              short *maxv) {\n#pragma HLS inline region off\n    *maxv = MINVAL;\n    int row, col;\n    short mat[MAXROW][MAXCOL];\n    for (col = 0; col < MAXCOL; col++) {\n        short d = refSeq[col];\n        for (row = 0; row < MAXROW; ++row) {\n            short n, nw, w;\n            if (row == 0) {\n                n = 0;\n            } else {\n                n = mat[row - 1][col];\n            }\n            if (col == 0) {\n                w = 0;\n            } else {\n                w = mat[row][col - 1];\n            }\n\n            if (row > 0 && col > 0) {\n                nw = mat[row - 1][col - 1];\n            } else {\n                nw = 0;\n            }\n\n            short q = readSeq[row];\n            short max = 0;\n            short match = (d == q) ? MATCH : MISS_MATCH;\n            short t1 = (nw + match > max) ? nw + match : max;\n            short t2 = (n + GAP > w + GAP) ? n + GAP : w + GAP;\n            max = t1 > t2 ? t1 : t2;\n            mat[row][col] = max;\n            if (max > *maxv) {\n                *maxv = max;\n                *maxr = row;\n                *maxc = col;\n            }\n        }\n    }\n}\n\nvoid sw(uint2_t d[MAXCOL],\n        uint2_t q[MAXROW],\n        short *maxr,\n        short *maxc,\n        short *maxv) {\n#pragma HLS inline region off\n    swSystolicBlocking(d, q, maxr, maxc, maxv, MAXROW, MAXCOL);\n}\n\ntemplate <int BUFFERSZ>\nvoid intTo2bit(unsigned int *buffer, uint2_t *buffer2b) {\n    int i, j;\n#pragma HLS PIPELINE II = 1\n    for (i = 0; i < BUFFERSZ; ++i) {\n        for (j = 0; j < 16; ++j) {\n            buffer2b[16 * i + j] = (buffer[i] & (3 << (2 * j))) >> (2 * j);\n        }\n    }\n}\n\ntemplate <int FACTOR>\nvoid swInt(unsigned int *readRefPacked, short *maxr, short *maxc, short *maxv) {\n#pragma HLS function_instantiate variable = maxv\n    uint2_t d2bit[MAXCOL];\n    uint2_t q2bit[MAXROW];\n#pragma HLS array partition variable = d2bit cyclic factor = FACTOR\n#pragma HLS array partition variable = q2bit cyclic factor = FACTOR\n\n    intTo2bit<MAXCOL / 16>((readRefPacked + MAXROW / 16), d2bit);\n    intTo2bit<MAXROW / 16>(readRefPacked, q2bit);\n    sw(d2bit, q2bit, maxr, maxc, maxv);\n}\n\nvoid swMaxScore(unsigned int readRefPacked[NUMPACKED][PACKEDSZ],\n                short out[NUMPACKED][3]) {\n    /*instantiate NUMPACKED PE*/\n    for (int i = 0; i < NUMPACKED; ++i) {\n       #pragma HLS UNROLL\n        swInt<MAXPE>(readRefPacked[i], &out[i][0], &out[i][1], &out[i][2]);\n    }\n}\n//#ifndef HLS_COMPILE\nextern \"C\" {\n//#endif\nvoid opencl_sw_maxscore(unsigned int *input, unsigned int *output, int *size) {\n#pragma HLS inline region off\n#pragma HLS INTERFACE m_axi port = input offset = slave bundle = gmem\n#pragma HLS INTERFACE m_axi port = output offset = slave bundle = gmem\n#pragma HLS INTERFACE m_axi port = size offset = slave bundle = gmem\n#pragma HLS INTERFACE s_axilite port = input bundle = control\n#pragma HLS INTERFACE s_axilite port = output bundle = control\n#pragma HLS INTERFACE s_axilite port = size bundle = control\n#pragma HLS INTERFACE s_axilite port = return bundle = control\n    unsigned int inbuf[PACKEDSZ * NUMPACKED];\n    unsigned int outbuf[3 * NUMPACKED];\n    unsigned int readRefPacked[NUMPACKED][PACKEDSZ];\n    short out[NUMPACKED][3];\n    int numIter;\n#pragma HLS array partition variable = readRefPacked dim = 1\n#pragma HLS array partition variable = out dim = 0\n    numIter = *size;\n    int loop = 0;\n    for (loop = 0; loop < numIter; loop++) {\n        /*read from device memory to BRAM*/\n        memcpy(readRefPacked,\n               (unsigned int *)(input + loop * PACKEDSZ * NUMPACKED),\n               UINTSZ * PACKEDSZ * NUMPACKED);\n        swMaxScore(readRefPacked, out);\n        /*PE OUT to outbuf*/\n        for (int i = 0; i < NUMPACKED; ++i) {\n           #pragma HLS PIPELINE\n            outbuf[3 * i] = out[i][0];\n            outbuf[3 * i + 1] = out[i][1];\n            outbuf[3 * i + 2] = out[i][2];\n        }\n        /*outbuf to device memory*/\n        memcpy((unsigned int *)(output + 3 * NUMPACKED * loop),\n               outbuf,\n               sizeof(unsigned int) * 3 * NUMPACKED);\n    }\n    return;\n}\n}\n"
    },
    "spmv": {
        "src": "#include <stdlib.h>\n#include <stdio.h>\n#include \"support.h\"\n\n// These constants valid for the IEEE 494 bus interconnect matrix\n#define NNZ 1666\n#define N 494\n#define L 10\n\n#define TYPE float\nvoid spmv(TYPE nzval[N*L], int32_t cols[N*L], TYPE vec[N], TYPE out[N])\n{\n    int i, j;\n    TYPE Si;\n\n    ellpack_1 : for (i=0; i<N; i++) {\n        TYPE sum = out[i];\n        ellpack_2 : for (j=0; j<L; j++) {\n                Si = nzval[j + i*L] * vec[cols[j + i*L]];\n                sum += Si;\n        }\n        out[i] = sum;\n    }\n}\n",
        "tgt": "#include \"ap_int.h\" \n#include \"ap_axi_sdata.h\" \n#include \"hls_stream.h\" \n#include <inttypes.h> \n#include <stdlib.h> \n\nconst int DWIDTH_256 = 256; \n#define INTERFACE_WIDTH_256 ap_uint<DWIDTH_256>\nconst int W_FACTOR_256 = DWIDTH_256/32;\nconst int DWIDTH_512 = 32; \n#define INTERFACE_WIDTH_512 ap_uint<DWIDTH_512>\nconst int W_FACTOR_512 = DWIDTH_512/32;\n\n#define TYPE float\nconst int NUM_ITERATIONS = 5000;\n\n#define NUM_KERNEL (4)\n\n#define N (8192)\n#define L (1024)\n\n#define N_OUT (N/NUM_KERNEL)\n#define ROWS_PER_TILE (64)\n#define NUM_TILES (N_OUT/ROWS_PER_TILE)\n#define UNROLL_FACTOR (4)\n\nextern \"C\" {\n\nvoid ellpack (TYPE* nzval, int* cols, TYPE* vec, TYPE* out)\n{\n#pragma HLS INLINE off\n    for (int i=0; i<ROWS_PER_TILE/UNROLL_FACTOR; i++) {\n    #pragma HLS PIPELINE\n\t\tout[i] = 0.0;\n    }\n    ellpack_2 : for (int j=0; j<L; j++) {\n    #pragma HLS PIPELINE\n    \tellpack_1 : for (int i=0; i<ROWS_PER_TILE/UNROLL_FACTOR; i++) {\n\t\t#pragma HLS UNROLL\n            out[i] = out[i] + nzval[j + i*L] * vec[cols[j + i*L]];\n        }\n    }\n}\n\nvoid buffer_compute (TYPE local_nzval[][L*ROWS_PER_TILE/UNROLL_FACTOR], int local_cols[][L*ROWS_PER_TILE/UNROLL_FACTOR], \n\t\t    TYPE local_vec[][N], TYPE local_out[][ROWS_PER_TILE/UNROLL_FACTOR], int flag, TYPE* out) {\n#pragma HLS INLINE off\n\tif (flag) {\n\t\tfor (int j=0; j<UNROLL_FACTOR; j++) {\n    \t#pragma HLS UNROLL\n\t\t\tellpack(local_nzval[j], local_cols[j], local_vec[j], local_out[j]);\n    \t}\n    \tfor (int i=0; i<UNROLL_FACTOR; i++) {\n\t\t\tfor (int j=0; j<ROWS_PER_TILE/UNROLL_FACTOR; j++) {\n\t\t\t#pragma HLS PIPELINE II=1\n\t\t\t\tout[i*ROWS_PER_TILE/UNROLL_FACTOR+j] = local_out[i][j];\n\t\t\t}\n    \t}\n  \t}\n}\n\nvoid load_nzval (volatile INTERFACE_WIDTH_256* nzval, TYPE local_nzval[][L*ROWS_PER_TILE/UNROLL_FACTOR], int flag) {\n#pragma HLS INLINE off\n\tif (flag) {\n\t\tconst int tile_length = L*ROWS_PER_TILE/W_FACTOR_256;\n\t\tfor (int i=0; i<tile_length; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t\tint row = i / (tile_length/UNROLL_FACTOR);\n\t\t\tint col = i % (tile_length/UNROLL_FACTOR);\n\t\t\tINTERFACE_WIDTH_256 temp_data = nzval[i];\n\t\t\tfor (int k=0; k<W_FACTOR_256; ++k){\n\t\t\t#pragma HLS UNROLL\n\t\t\t\tunsigned int range_idx = k * 32;\n\t\t\t\tuint32_t tmp_int = temp_data.range(range_idx+31, range_idx);\n\t\t\t\tfloat tmp_float = *((float*)(&tmp_int));\n\t\t\t\tlocal_nzval[row][col*W_FACTOR_256+k] = tmp_float;\n\t\t\t}\n\t\t}\n  \t}\n}\n\nvoid load_cols (volatile INTERFACE_WIDTH_256* cols, int local_cols[][L*ROWS_PER_TILE/UNROLL_FACTOR], int flag) {\n#pragma HLS INLINE off\n  \tif (flag) {\n\t\tconst int tile_length = L*ROWS_PER_TILE/W_FACTOR_256;\n\t\tfor (int i=0; i<tile_length; ++i){\n\t\t#pragma HLS PIPELINE II=1\n\t\t\tint row = i / (tile_length/UNROLL_FACTOR);\n\t\t\tint col = i % (tile_length/UNROLL_FACTOR);\n\t\t\tINTERFACE_WIDTH_256 temp_data = cols[i];\n\t\t\tfor (int k=0; k<W_FACTOR_256; ++k){\n\t\t\t#pragma HLS UNROLL\n\t\t\t\tunsigned int range_idx = k * 32;\n\t\t\t\tuint32_t tmp = temp_data.range(range_idx+31, range_idx);\n\t\t\t\tint tmp_int = *((int*)(&tmp));\n\t\t\t\tlocal_cols[row][col*W_FACTOR_256+k] = tmp_int;\n\t\t\t}\n\t\t}\n  \t}\n}\n\nvoid buffer_load(volatile INTERFACE_WIDTH_256* nzval, TYPE local_nzval[][L*ROWS_PER_TILE/UNROLL_FACTOR], \n\t\t\t\t volatile INTERFACE_WIDTH_256* cols, int local_cols[][L*ROWS_PER_TILE/UNROLL_FACTOR], int flag){\n#pragma HLS INLINE off\n#pragma HLS DATAFLOW\n\tload_nzval(nzval, local_nzval, flag);\n\tload_cols(cols, local_cols, flag);\n}\n\nvoid spmv(volatile INTERFACE_WIDTH_256* nzval, \n\t\t\t\t\t  volatile INTERFACE_WIDTH_256* cols, \n\t\t\t\t\t  INTERFACE_WIDTH_512* vec, INTERFACE_WIDTH_512* out) {\n#pragma HLS INTERFACE m_axi port=nzval offset=slave bundle=gmem0 max_read_burst_length=64\n#pragma HLS INTERFACE m_axi port=cols  offset=slave bundle=gmem1 max_read_burst_length=64\n#pragma HLS INTERFACE m_axi port=vec   offset=slave bundle=gmem2 max_read_burst_length=256 max_write_burst_length=256\n#pragma HLS INTERFACE m_axi port=out   offset=slave bundle=gmem2 max_read_burst_length=256 max_write_burst_length=256\n#pragma HLS INTERFACE s_axilite port=nzval bundle=control\n#pragma HLS INTERFACE s_axilite port=cols bundle=control\n#pragma HLS INTERFACE s_axilite port=vec bundle=control\n#pragma HLS INTERFACE s_axilite port=out bundle=control\n#pragma HLS INTERFACE s_axilite port=return bundle=control\n\n\tTYPE local_nzval_x[UNROLL_FACTOR][L*ROWS_PER_TILE/UNROLL_FACTOR];\n#pragma HLS ARRAY_PARTITION variable=local_nzval_x dim=1 complete\n#pragma HLS ARRAY_PARTITION variable=local_nzval_x dim=2 cyclic factor=W_FACTOR_256\n#pragma HLS RESOURCE variable=local_nzval_x core=XPM_MEMORY uram\n\tTYPE local_nzval_y[UNROLL_FACTOR][L*ROWS_PER_TILE/UNROLL_FACTOR];\n#pragma HLS ARRAY_PARTITION variable=local_nzval_y dim=1 complete\n#pragma HLS ARRAY_PARTITION variable=local_nzval_y dim=2 cyclic factor=W_FACTOR_256\n#pragma HLS RESOURCE variable=local_nzval_y core=XPM_MEMORY uram\n\n\tint local_cols_x[UNROLL_FACTOR][L*ROWS_PER_TILE/UNROLL_FACTOR];\n#pragma HLS ARRAY_PARTITION variable=local_cols_x dim=1 complete\n#pragma HLS ARRAY_PARTITION variable=local_cols_x dim=2 cyclic factor=W_FACTOR_256\n\tint local_cols_y[UNROLL_FACTOR][L*ROWS_PER_TILE/UNROLL_FACTOR];\n#pragma HLS ARRAY_PARTITION variable=local_cols_y dim=1 complete\n#pragma HLS ARRAY_PARTITION variable=local_cols_y dim=2 cyclic factor=W_FACTOR_256\n\n\t//read 'vec' from DRAM\n\tTYPE temp_vec[N];\n#pragma HLS ARRAY_PARTITION variable=temp_vec cyclic factor=W_FACTOR_512\n\tfor (int i=0; i<N/W_FACTOR_512; ++i){\n\t#pragma HLS PIPELINE II=1\n\t\tINTERFACE_WIDTH_512 temp_data = vec[i];\n\t\tfor (int j=0; j<W_FACTOR_512; ++j){\n\t\t#pragma HLS UNROLL\n\t\t\tunsigned int range_idx = j * 32;\n\t\t\tuint32_t tmp_int = temp_data.range(range_idx + 31, range_idx);\n\t\t\tfloat tmp_float = *((float*)(&tmp_int));\n\t\t\ttemp_vec[i*W_FACTOR_512+j] = tmp_float;\n\t\t}\n\t}\n\tTYPE local_vec[UNROLL_FACTOR][N];\n#pragma HLS ARRAY_PARTITION variable=local_vec dim=1 complete\n\tfor(int i=0; i<N; i++) {\n    #pragma HLS PIPELINE II=1\n\t    for(int j=0; j<UNROLL_FACTOR; j++) {\n\t    #pragma HLS UNROLL\n\t        local_vec[j][i] = temp_vec[i];\n\t    }\n\t} \n\n\tTYPE local_out[UNROLL_FACTOR][ROWS_PER_TILE/UNROLL_FACTOR];\n#pragma HLS ARRAY_PARTITION variable=local_out dim=0 complete\n\tTYPE all_out[N_OUT];\n#pragma HLS ARRAY_PARTITION variable=all_out cyclic factor=W_FACTOR_512\n\n\tint load_flag, compute_flag;\n\tfor (int it=0; it<NUM_ITERATIONS; ++it){\n\t\tfor (int i=0; i<NUM_TILES+1; i++) {\n\t\t\tload_flag = i >= 0 && i < NUM_TILES;\n\t\t\tcompute_flag = i > 0 && i <= NUM_TILES;\n\t\t\tif (i % 2 == 0) {\n\t\t\t\tbuffer_load(nzval + i*ROWS_PER_TILE*L/W_FACTOR_256, local_nzval_x, cols + i*ROWS_PER_TILE*L/W_FACTOR_256, local_cols_x, load_flag);\n\t\t\t\tbuffer_compute(local_nzval_y, local_cols_y, local_vec, local_out, compute_flag, all_out + (i-1)*ROWS_PER_TILE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuffer_load(nzval + i*ROWS_PER_TILE*L/W_FACTOR_256, local_nzval_y, cols + i*ROWS_PER_TILE*L/W_FACTOR_256, local_cols_y, load_flag);\n\t\t\t\tbuffer_compute(local_nzval_x, local_cols_x, local_vec, local_out, compute_flag, all_out + (i-1)*ROWS_PER_TILE);\n\t\t\t}\n\t\t}\n\t}\n\n\t//write 'out' to DRAM\n\tfor (int i=0; i<N_OUT/W_FACTOR_512; ++i){\n\t#pragma HLS PIPELINE II=1\n\t\tfor (int j=0; j<W_FACTOR_512; ++j){\n\t\t#pragma HLS UNROLL\n\t\t\tunsigned int range_idx = j * 32;\n\t\t\tfloat tmp_flt = all_out[i*W_FACTOR_512+j];\n\t\t\tout[i].range(range_idx+31, range_idx) = *((uint32_t *)(&tmp_flt));\n\t\t}\n\t}\n\n\treturn;\n}\n\n}\n"
    },
    "sgd": {
        "src": "#include \"math.h\"\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n  // software version uses C++ built-in datatypes\ntypedef float FeatureType;\ntypedef float DataType;\ntypedef unsigned char LabelType;\nFeatureType dotProduct(FeatureType param[NUM_FEATURES],\n                       DataType    feature[NUM_FEATURES])\n{\n  FeatureType result = 0;\n  DOT: for (int i = 0; i < NUM_FEATURES; i++)\n    result += param[i] * feature[i];\n  return result;\n}\nFeatureType Sigmoid(FeatureType exponent) \n{\n  return 1 / (1 + expf(-exponent));\n}\n// Compute the gradient of the cost function\nvoid computeGradient(\n    FeatureType grad[NUM_FEATURES],\n    DataType    feature[NUM_FEATURES],\n    FeatureType scale)\n{\n  GRAD: for (int i = 0; i < NUM_FEATURES; i++)\n    grad[i] = scale * feature[i];\n}\n// Update the parameter vector\nvoid updateParameter(\n    FeatureType param[NUM_FEATURES],\n    FeatureType grad[NUM_FEATURES],\n    FeatureType scale)\n{\n  UPDATE: for (int i = 0; i < NUM_FEATURES; i++)\n    param[i] += scale * grad[i];\n}\n// top-level function \nvoid sgd( DataType    data[NUM_FEATURES * NUM_TRAINING],\n               LabelType   label[NUM_TRAINING],\n               FeatureType theta[NUM_FEATURES])\n{\n  // intermediate variable for storing gradient\n  FeatureType gradient[NUM_FEATURES];\n  // main loop\n  // runs for multiple epochs\n  EPOCH: for (int epoch = 0; epoch < NUM_EPOCHS; epoch ++) \n  {\n    // in each epoch, go through each training instance in sequence\n    TRAINING_INST: for( int training_id = 0; training_id < NUM_TRAINING; training_id ++ )\n    { \n      // dot product between parameter vector and data sample \n      FeatureType dot = dotProduct(theta, &data[NUM_FEATURES * training_id]);\n      // sigmoid\n      FeatureType prob = Sigmoid(dot);\n      // compute gradient\n      computeGradient(gradient, &data[NUM_FEATURES * training_id], (prob - label[training_id]));\n      // update parameter vector\n      updateParameter(theta, gradient, -STEP_SIZE);\n    }\n  }\n}",
        "tgt": "#include \"ap_int.h\"\n#include \"ap_fixed.h\"\n#include \"hls_math.h\"\n\n// dataset information\nconst int NUM_FEATURES  = 1024;\nconst int NUM_SAMPLES   = 5000;\nconst int NUM_TRAINING  = 4500;\nconst int NUM_TESTING   = 500;\nconst int STEP_SIZE     = 60000; \nconst int NUM_EPOCHS    = 5;\nconst int DATA_SET_SIZE = NUM_FEATURES * NUM_SAMPLES;\n\n// take advantage of the off-chip bandwidth of ocl platforms\n#define VFTYPE_WIDTH  512\n#define VDTYPE_WIDTH  512\n\n// features / parameters\n#define FTYPE_TWIDTH 32\n#define FTYPE_IWIDTH 13\ntypedef ap_fixed<FTYPE_TWIDTH,FTYPE_IWIDTH> FeatureType;\ntypedef ap_uint<VFTYPE_WIDTH>               VectorFeatureType;\nconst unsigned int F_VECTOR_SIZE = VFTYPE_WIDTH / FTYPE_TWIDTH;\n// training data\n#define DTYPE_TWIDTH 16\n#define DTYPE_IWIDTH 4\n\ntypedef ap_fixed<DTYPE_TWIDTH,DTYPE_IWIDTH>  DataType;\ntypedef ap_uint<VDTYPE_WIDTH>                VectorDataType;\nconst unsigned int D_VECTOR_SIZE = VDTYPE_WIDTH / DTYPE_TWIDTH;\n\n// label\n#define LTYPE_WIDTH   8\n#define VLTYPE_WIDTH  32\ntypedef ap_uint<LTYPE_WIDTH>                 LabelType;\ntypedef ap_uint<VLTYPE_WIDTH>                VectorLabelType;\nconst unsigned int L_VECTOR_SIZE = VLTYPE_WIDTH / LTYPE_WIDTH;\n#define PAR_FACTOR 32\n\n\nvoid read_data(VectorDataType  data[NUM_FEATURES / D_VECTOR_SIZE], \n               DataType        training_instance[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n\n  READ_TRAINING_DATA: for (int i = 0; i < NUM_FEATURES / D_VECTOR_SIZE; i ++ )\n  {\n    #pragma HLS pipeline II=1\n    VectorFeatureType tmp_data = data[i];\n    READ_TRAINING_DATA_INNER: for (int j = 0; j < D_VECTOR_SIZE; j ++ )\n      training_instance[i * D_VECTOR_SIZE + j].range(DTYPE_TWIDTH-1, 0) = tmp_data.range((j+1)*DTYPE_TWIDTH-1, j*DTYPE_TWIDTH);\n  }\n}\n\n// Function to compute the dot product of data (feature) vector and parameter vector\nFeatureType dotProduct(FeatureType param[NUM_FEATURES],\n                       DataType    feature[NUM_FEATURES])\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n  \n  #pragma HLS array_partition variable=param cyclic factor=unroll_factor\n  #pragma HLS array_partition variable=param cyclic factor=unroll_factor\n\n  FeatureType result = 0;\n  DOT: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    DOT_INNER: for(int j = 0; j < PAR_FACTOR; j++) \n    {\n      FeatureType term = param[i*PAR_FACTOR+j] * feature[i*PAR_FACTOR+j];\n      result += term;\n    }\n  }\n  return result;\n}\n\nFeatureType Sigmoid(FeatureType exponent) \n{\n  return 1 / (1 + hls::expf(-exponent));\n}\n\n// Compute the gradient of the cost function\nvoid computeGradient(\n    FeatureType grad[NUM_FEATURES],\n    DataType    feature[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n  #pragma HLS array_partition variable=grad cyclic factor=unroll_factor\n  #pragma HLS array_partition variable=feature cyclic factor=unroll_factor\n  GRAD: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    GRAD_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      grad[i*PAR_FACTOR+j] = (scale * feature[i*PAR_FACTOR+j]);\n  }\n}\n\n// Update the parameter vector\nvoid updateParameter(\n    FeatureType param[NUM_FEATURES],\n    FeatureType grad[NUM_FEATURES],\n    FeatureType scale)\n{\n  #pragma HLS INLINE\n  const int unroll_factor = PAR_FACTOR;\n  #pragma HLS array_partition variable=grad cyclic factor=unroll_factor\n  #pragma HLS array_partition variable=param cyclic factor=unroll_factor\n\n  UPDATE: for (int i = 0; i < NUM_FEATURES / PAR_FACTOR; i++)\n  {\n    #pragma HLS PIPELINE II=1\n    UPDATE_INNER: for (int j = 0; j < PAR_FACTOR; j++)\n      param[i*PAR_FACTOR+j] += scale * grad[i*PAR_FACTOR+j];\n  }\n}\n\n// stream out the data\nvoid streamOut(FeatureType theta_local[NUM_FEATURES], VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE])\n{\n  #pragma HLS INLINE\n  // stream out the result\n  STREAM_OUT: for (int i = 0; i < NUM_FEATURES / F_VECTOR_SIZE; i ++ )\n  {\n    #pragma HLS pipeline II=1\n    VectorFeatureType tmp_theta = 0;\n    STREAM_OUT_INNER: for (int j = 0; j < F_VECTOR_SIZE; j ++ )\n      tmp_theta.range((j+1)*FTYPE_TWIDTH-1, j*FTYPE_TWIDTH) = theta_local[i * F_VECTOR_SIZE + j].range(FTYPE_TWIDTH-1, 0);\n    theta[i] = tmp_theta;\n  }\n\n}\n\n// wrapper, wraps the compute part for dataflow\nvoid compute(FeatureType theta_local[NUM_FEATURES], \n             LabelType training_label,\n             DataType training_instance[NUM_FEATURES])\n{\n  // array for storing gradient\n  FeatureType gradient[NUM_FEATURES];\n\n  // step size\n  FeatureType step = STEP_SIZE;\n\n  // do dot product with the parameter vector\n  FeatureType dot = dotProduct(theta_local, training_instance);\n  // do sigmoid function\n  FeatureType prob = Sigmoid(dot);\n  // compute gradient\n  computeGradient(gradient, training_instance, (prob-training_label));\n  // update the param vector\n  updateParameter(theta_local, gradient, -step);\n}\n\n\n\n// top-level function \nvoid sgd( VectorDataType    data[NUM_FEATURES * NUM_TRAINING / D_VECTOR_SIZE],\n            VectorLabelType   label[NUM_TRAINING / L_VECTOR_SIZE],\n            VectorFeatureType theta[NUM_FEATURES / F_VECTOR_SIZE],\n            bool readLabels,\n            bool writeOutput)\n{\n  // intermediate variables \n\n  // local version of the parameters\n  static FeatureType theta_local[NUM_FEATURES];\n  // local buffer of labels\n  static LabelType   label_local[NUM_TRAINING];\n  #pragma HLS array_partition variable=label_local cyclic factor=L_VECTOR_SIZE\n  // array for storing one training instance\n  static DataType training_instance[NUM_FEATURES];\n\n  if (readLabels)\n  {\n    // copy in labels\n    LABEL_CP: for (int i = 0; i < NUM_TRAINING / L_VECTOR_SIZE; i ++ )\n    {\n      #pragma HLS pipeline\n      VectorLabelType tmp_label = label[i];\n      LABEL_CP_INNER: for (int j = 0; j < L_VECTOR_SIZE; j ++ )\n        label_local[i * L_VECTOR_SIZE + j].range(LTYPE_WIDTH-1, 0) = tmp_label.range((j+1)*LTYPE_WIDTH-1, j*LTYPE_WIDTH);\n    }\n  }\n\n  // main loop\n  // in each epoch, go through each training instance in sequence\n  TRAINING_INST: for( int training_id = 0; training_id < NUM_TRAINING; training_id ++ )\n  {  \n    #pragma HLS dataflow\n    // get the label\n    LabelType training_label = label_local[training_id];\n    // first reads in the training instance\n    read_data(data + training_id * NUM_FEATURES / D_VECTOR_SIZE, training_instance);\n    // compute part\n    compute(theta_local, training_label, training_instance);\n  }\n\n  if (writeOutput)\n    streamOut(theta_local, theta);\n}\n\n"
    }
}